// Copyright (C) Microsoft Corporation. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// # API Review
// All APIs need API review. List API review documents here with the URI to the
// doc and the change ID of the IDL when the document was created.
// API documents:
//  * 916246ec [WebView2 API Specification](https://aka.ms/WebView2APISpecification)
//
// # Style
// Follow the [Win32 API Design Guidelines](https://aka.ms/Win32APIDesignGuidelines)
// while editing this file. For any style rules unspecified follow the Anaheim
// style. Specifically, follow Anaheim indenting and line limit style rules in
// this file.
//
// # Documentation
// Please ensure that any new API includes complete documentation in its
// JavaDoc comments in this file and sample usage in the Sample App.
// Comments intended for public API documentation should start with 3 slashes.
// The first sentence is the brief the brief description of the API and
// shouldn't include the name of the API. Use markdown to style your public API
// documentation.
//
// # WebView and JavaScript capitalization
//    camel case  | webViewExample  | javaScriptExample
//    Pascal case | WebViewExample  | JavaScriptExample
//    Upper case  | WEBVIEW_EXAMPLE | JAVASCRIPT_EXAMPLE
//
// That said, in API names use the term 'script' rather than 'JavaScript'.
// Script is shorter and there is only one supported scripting language on the
// web so the specificity of JavaScript is unnecessary.
//
// # URI (not URL)
// We use Uri in parameter names and type names
// throughout. URIs identify resources while URLs (a subset of URIs) also
// locates resources. This difference is not generally well understood. Because
// all URLs are URIs we can ignore the conversation of trying to explain the
// difference between the two and still be technically accurate by always using
// the term URI. Additionally, whether a URI is locatable depends on the context
// since end developers can at runtime specify custom URI scheme resolvers.
//
// # Event pattern
// Events have a method to add and to remove event handlers:
// ```
// HRESULT add_{EventName}(
//     ICoreWebView2{EventName}EventHandler* eventHandler,
//     EventRegistrationToken* token);
//
// HRESULT remove_{EventName}(EventRegistrationToken token);
// ```
// Add takes an event handler delegate interface with a single Invoke method.
// ```
// ICoreWebView2{EventName}EventHandler::Invoke(
//     {SenderType}* sender,
//     ICoreWebView2{EventHandler}EventArgs* args);
// ```
// The Invoke method has two parameters. The first is the sender, the object
// which is firing the event. The second is the EventArgs type. It doesn't take
// the event arg parameters directly so we can version interfaces correctly.
// If the event has no properties on its event args type, then the Invoke method
// should take IUnknown* as its event args parameter so it is possible to add
// event args interfaces in the future without requiring a new event. For events
// with no sender (a static event), the Invoke method has only the event args
// parameter.
//
// # Deferrable event pattern
// Generally, events should be deferrable when their event args have settable
// properties. In order for the caller to use asynchronous methods to produce
// the value for those settable properties we must allow the caller to defer
// the WebView reading those properties until asynchronously later. A deferrable
// event should have the following method on its event args interface:
//   `HRESULT GetDeferral([out, retval] ICoreWebView2Deferral** deferral);`
// If called, the event is deferred and calling Complete on the
// ICoreWebView2Deferral ends the deferral.
//
// # Asynchronous method pattern
// Async methods take a final parameter that is the completed handler:
//   `{MethodName}(..., ICoreWebView2{MethodName}CompletedHandler* handler)`
// The handler has a single Invoke method:
//   `ICoreWebView2{MethodName}CompletedHandler::Invoke(
//       HRESULT errorCode, {AsyncReturnType});`
//
// # Property pattern
// For properties with getters in IDL you have
//   `HRESULT get_{PropertyName}([out, retval] {PropertyType}*)`
// And for properties which also have setters in IDL you have
//   `HRESULT put_{PropertyName}([in] {PropertyType});`
//
// # Versioning
// The loader DLL may be older or newer than the client DLL. We have to deal
// with compatibility across several dimensions:
//  * There's the DLL export contract between the loader DLL and the client
//    DLL as well as the interfaces defined in this IDL that are built into both
//    the app code and the client DLL.
//  * There are two kinds of versioned changes we need to be able to make:
//    compatible changes and breaking changes. In both cases we need to make the
//    change in a safe manner. For compatible that means everything continues to
//    work unchanged despite the loader and client being different versions. For
//    breaking chnages this means the host app is unable to create a
//    WebView using the different version browser and receives an associated
//    error message (doesn't crash).
//  * We also need to consider when the loader and host app is using a newer
//    version than the browser and when the loader and host app is using an
//    older version than the browser.
//
// ## Scenario 1: Older SDK in host app, Newer browser, Compatible change
// In order to be compatible the newer client DLL must still support the older
// client DLL exports. Similarly for the interfaces - they must all be exactly
// the same with no modified IIDs, no reordered methods, no modified method
// parameters etc. The client DLL may have more DLL exports and more interfaces
// but no changes to the older shipped DLL export or interfaces.
// App code doesn't need to do anything special in this case.
//
// ## Scenario 2: Older SDK in host app, Newer browser, Breaking change
// For breaking changes in the DLL export, the client DLL must change the DLL
// export name. The old loader will attempt to use the old client DLL export.
// When the loader finds the export missing it will fail.
// For breaking changes in the interface, we must change the IID of the modified
// interface. Additionally the loader DLL must validate that the returned object
// supports the IID it expects and fail otherwise.
// The app code must ensure that WebView objects succeed in their QueryInterface
// calls. Basically the app code must have error handling for objects failing
// QueryInterface and for the initial creation failing in order to handle
// breaking changes gracefully.
//
// ## Scenario 3: Newer SDK in host app, Older browser, Compatible change
// In order to be compatible, the newer loader DLL must fallback to calling the
// older client DLL exports if the client DLL doesn't have the most recent DLL
// exports.
// For interface versioning the loader DLL shouldn't be impacted.
// The app code must not assume an object supports all newer versioned
// interfaces. Ideally it checks the success of QueryInterface for newer
// interfaces and if not supported turns off associated app features or
// otherwise fails gracefully.
//
// ## Scenario 4: Newer SDK in host app, Older browser, Breaking change
// For breaking changes in the DLL export, a new export name will be used after
// a breaking change and the loader DLL will just not check for pre-breaking
// change exports from the client DLL. If the client DLL doesn't have the
// correct exports, then the loader returns failure to the caller.
// For breaking changes in the interface, the IIDs of broken interfaces will
// have been modified. The loader will validate that the
// object returned supports the correct base interface IID and return failure to
// the caller otherwise.
// The app code must allow for QueryInterface calls to fail if the object
// doesn't support the newer IIDs.
//
// ## Actions
//  * DLL export compatible changes: Create a new DLL export with a new name.
//    Ideally implement the existing DLL export as a call into the new DLL
//    export to reduce upkeep burden.
//  * DLL export breaking changes: Give the modified DLL export a new name and
//    remove all older DLL exports.
//  * Interface compatible changes: Don't modify shipped interfaces. Add a new
//    interface with an incremented version number suffix
//    (ICoreWebView2_3) or feature group name suffix
//    (ICoreWebView2WithNavigationHistory).
//  * Interface breaking changes: After modifying a shipped interface, give it
//    a new IID.
//  * Loader: When finding the client DLL export it must check its known range
//    of compatible exports in order from newest to oldest and use the newest
//    one found. It must not attempt to use an older export from before a
//    breaking change. Before returning objects to the caller, the loader must
//    validate that the object actually implements the expected interface.
//  * App code: Check for error from the DLL export methods as they can fail if
//    the loader is used with an old browser from before a breaking change or
//    with a newer browser that is after a breaking change.
//    Check for errors when calling QueryInterface on a WebView object. The
//    QueryInterface call may fail with E_NOINTERFACE if the object is from an
//    older browser version that doesn't support the newer interface or if
//    using a newer browser version that had a breaking change on that
//    interface.
import "objidl.idl";
import "oaidl.idl";
import "EventToken.idl";

// Interface forward declarations
interface ICoreWebView2AcceleratorKeyPressedEventArgs;
interface ICoreWebView2AcceleratorKeyPressedEventHandler;
interface ICoreWebView2AddScriptToExecuteOnDocumentCreatedCompletedHandler;
interface ICoreWebView2CallDevToolsProtocolMethodCompletedHandler;
interface ICoreWebView2CapturePreviewCompletedHandler;
interface ICoreWebView2;
interface ICoreWebView2Host;
interface ICoreWebView2ContentLoadingEventArgs;
interface ICoreWebView2ContentLoadingEventHandler;
interface ICoreWebView2DocumentTitleChangedEventHandler;
interface ICoreWebView2ContainsFullScreenElementChangedEventHandler;
interface ICoreWebView2CreateCoreWebView2HostCompletedHandler;
interface ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler;
interface ICoreWebView2Deferral;
interface ICoreWebView2DevToolsProtocolEventReceivedEventArgs;
interface ICoreWebView2DevToolsProtocolEventReceivedEventHandler;
interface ICoreWebView2DevToolsProtocolEventReceiver;
interface ICoreWebView2Environment;
interface ICoreWebView2ExecuteScriptCompletedHandler;
interface ICoreWebView2FocusChangedEventHandler;
interface ICoreWebView2HistoryChangedEventHandler;
interface ICoreWebView2HttpHeadersCollectionIterator;
interface ICoreWebView2HttpRequestHeaders;
interface ICoreWebView2HttpResponseHeaders;
interface ICoreWebView2MoveFocusRequestedEventArgs;
interface ICoreWebView2MoveFocusRequestedEventHandler;
interface ICoreWebView2NavigationCompletedEventArgs;
interface ICoreWebView2NavigationCompletedEventHandler;
interface ICoreWebView2NavigationStartingEventArgs;
interface ICoreWebView2NavigationStartingEventHandler;
interface ICoreWebView2NewBrowserVersionAvailableEventHandler;
interface ICoreWebView2NewWindowRequestedEventArgs;
interface ICoreWebView2NewWindowRequestedEventHandler;
interface ICoreWebView2PermissionRequestedEventArgs;
interface ICoreWebView2PermissionRequestedEventHandler;
interface ICoreWebView2ProcessFailedEventArgs;
interface ICoreWebView2ProcessFailedEventHandler;
interface ICoreWebView2ScriptDialogOpeningEventArgs;
interface ICoreWebView2ScriptDialogOpeningEventHandler;
interface ICoreWebView2Settings;
interface ICoreWebView2SourceChangedEventArgs;
interface ICoreWebView2SourceChangedEventHandler;
interface ICoreWebView2WebMessageReceivedEventArgs;
interface ICoreWebView2WebMessageReceivedEventHandler;
interface ICoreWebView2WebResourceRequest;
interface ICoreWebView2WebResourceRequestedEventArgs;
interface ICoreWebView2WebResourceRequestedEventHandler;
interface ICoreWebView2WebResourceResponse;
interface ICoreWebView2ZoomFactorChangedEventHandler;
interface ICoreWebView2WindowCloseRequestedEventHandler;

/// WebView2 enables you to host web content using the
/// latest Edge web browser technology.
///
/// ## Navigation events
/// The normal sequence of navigation events is NavigationStarting,
/// SourceChanged, ContentLoading and then NavigationCompleted.
///
/// \dot
/// digraph NavigationEvents {
///    node [fontname=Roboto, shape=rectangle]
///    edge [fontname=Roboto]
///
///    NewDocument -> NavigationStarting;
///    NavigationStarting -> SourceChanged -> ContentLoading [label="New Document"];
///    ContentLoading -> HistoryChanged;
///    SameDocument -> SourceChanged;
///    SourceChanged -> HistoryChanged [label="Same Document"];
///    HistoryChanged -> NavigationCompleted;
///    NavigationStarting -> NavigationStarting [label="Redirect"];
///    NavigationStarting -> NavigationCompleted [label="Failure"];
/// }
/// \enddot
///
/// Note that this is for navigation events with the same NavigationId event
/// arg. Navigations events with different NavigationId event args may overlap.
/// For instance, if you start a navigation wait for its NavigationStarting
/// event and then start another navigation you'll see the NavigationStarting
/// for the first navigate followed by the NavigationStarting of the second
/// navigate, followed by the NavigationCompleted for the first navigation and
/// then all the rest of the appropriate navigation events for the second
/// navigation.
/// In error cases there may or may not be a ContentLoading event depending
/// on whether the navigation is continued to an error page.
/// In case of an HTTP redirect, there will be multiple NavigationStarting
/// events in a row, with ones following the first will have their IsRedirect
/// flag set.
///
/// To monitor or cancel navigations inside subframes in the WebView, use
/// FrameNavigationStarting.
///
/// ## Process model
/// WebView2 uses the same process model as the Edge web
/// browser. There is one Edge browser process per specified user data directory
/// in a user session that will serve any WebView2 calling
/// process that specifies that user data directory. This means one Edge browser
/// process may be serving multiple calling processes and one calling
/// process may be using multiple Edge browser processes.
///
/// \dot
/// digraph ProcessModelNClientsNServers {
///     node [fontname=Roboto, shape=rectangle];
///     edge [fontname=Roboto];
///
///     Host1 [label="Calling\nprocess 1"];
///     Host2 [label="Calling\nprocess 2"];
///     Browser1 [label="Edge processes\ngroup 1"];
///     Browser2 [label="Edge processes\ngroup 2"];
///
///     Host1 -> Browser1;
///     Host1 -> Browser2;
///     Host2 -> Browser2;
/// }
/// \enddot
///
/// Off of a browser process there will be some number of renderer processes.
/// These are created as
/// necessary to service potentially multiple frames in different WebViews. The
/// number of renderer processes varies based on the site isolation browser
/// feature and the number of distinct disconnected origins rendered in
/// associated WebViews.
///
/// \dot
/// digraph ProcessModelClientServer {
///     node [fontname=Roboto, shape=rectangle];
///     edge [fontname=Roboto];
///     graph [fontname=Roboto];
///
///     Host [label="Calling process"];
///     subgraph cluster_0 {
///         labeljust = "l";
///         label = "Edge processes group";
///         Browser [label="Edge browser\nprocess"];
///         Render1 [label="Edge render\nprocess 1"];
///         Render2 [label="Edge render\nprocess 2"];
///         RenderN [label="Edge render\nprocess N"];
///         GPU [label="Edge GPU\nprocess"];
///     }
///
///     Host -> Browser;
///     Browser -> Render1;
///     Browser -> Render2;
///     Browser -> RenderN;
///     Browser -> GPU;
/// }
/// \enddot
///
/// You can react to crashes and hangs in these browser and renderer processes
/// using the ProcessFailure event.
///
/// You can safely shutdown associated browser and renderer processes using the
/// Close method.
///
/// ## Threading model
/// The WebView2 must be created on a UI thread. Specifically a
/// thread with a message pump. All callbacks will occur on that thread and
/// calls into the WebView must be done on that thread. It is not safe to use
/// the WebView from another thread.
///
/// Callbacks including event handlers and completion handlers execute serially.
/// That is, if you have an event handler running and begin a message loop no
/// other event handlers or completion callbacks will begin executing
/// reentrantly.
///
/// ## Security
/// Always check the Source property of the WebView before using ExecuteScript,
/// PostWebMessageAsJson, PostWebMessageAsString, or any other method to send
/// information into the WebView. The WebView may have navigated to another page
/// via the end user interacting with the page or script in the page causing
/// navigation. Similarly, be very careful with
/// AddScriptToExecuteOnDocumentCreated. All future navigations will run this
/// script and if it provides access to information intended only for a certain
/// origin, any HTML document may have access.
///
/// When examining the result of an ExecuteScript method call, a
/// WebMessageReceived event, always check the Source of the sender, or any
/// other mechanism of receiving information from an HTML document in a WebView
/// validate the URI of the HTML document is what you expect.
///
/// When constructing a message to send into a WebView, prefer using
/// PostWebMessageAsJson and construct the JSON string parameter using a JSON
/// library. This will avoid any potential accidents of encoding information
/// into a JSON string or script and ensure no attacker controlled input can
/// modify the rest of the JSON message or run arbitrary script.
///
/// ## String types
/// String out parameters are LPWSTR null terminated strings. The callee
/// allocates the string using CoTaskMemAlloc. Ownership is transferred to the
/// caller and it is up to the caller to free the memory using CoTaskMemFree.
///
/// String in parameters are LPCWSTR null terminated strings. The caller ensures
/// the string is valid for the duration of the synchronous function call.
/// If the callee needs to retain that value to some point after the function
/// call completes, the callee must allocate its own copy of the string value.
///
/// ## URI and JSON parsing
/// Various methods provide or accept URIs and JSON as strings. Please use your
/// own preferred library for parsing and generating these strings.
///
/// If WinRT is available for your app you can use `RuntimeClass_Windows_Data_Json_JsonObject`
/// and `IJsonObjectStatics` to parse or produce JSON strings or `RuntimeClass_Windows_Foundation_Uri`
/// and `IUriRuntimeClassFactory` to parse and produce URIs. Both of these work
/// in Win32 apps.
///
/// If you use IUri and CreateUri to parse URIs you may want to use the
/// following URI creation flags to have CreateUri behavior more closely match
/// the URI parsing in the WebView:
/// `Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME | Uri_CREATE_NO_DECODE_EXTRA_INFO`
///
/// ## Debugging
/// Open DevTools with the normal shortcuts: `F12` or `Ctrl+Shift+I`.
/// You can use the `--auto-open-devtools-for-tabs` command argument switch to
/// have the DevTools window open immediately when first creating a WebView. See
/// CreateCoreWebView2Host documentation for how to provide additional command
/// line arguments to the browser process.
/// Check out the LoaderOverride registry key for trying out different builds of
/// WebView2 without modifying your application in the CreateCoreWebView2Host
/// documentation.
///
/// ## Versioning
/// After you've used a particular version of the SDK to build your app, your
/// app may end up running with an older or newer version of installed browser
/// binaries. Until version 1.0.0.0 of WebView2 there may be breaking changes
/// during updates that will prevent your SDK from working with different
/// versions of installed browser binaries. After version 1.0.0.0 different
/// versions of the SDK can work with different versions of the installed
/// browser by following these best practices:
///
/// To account for breaking changes to the API be sure to check for failure when
/// calling the DLL export CreateCoreWebView2Environment and when
/// calling QueryInterface on any CoreWebView2 object. A return value of
/// E_NOINTERFACE can indicate the SDK is not compatible with the Edge
/// browser binaries.
///
/// Checking for failure from QueryInterface will also account for cases where
/// the SDK is newer than the version of the Edge browser and your app attempts
/// to use an interface of which the Edge browser is unaware.
///
/// When an interface is unavailable, you can consider disabling the associated
/// feature if possible, or otherwise informing the end user they need to update
/// their browser.
[uuid(5cc5293d-af6f-41d4-9619-44bd31ba4c93), object, pointer_default(unique)]
interface ICoreWebView2 : IUnknown {
  /// Image format used by the ICoreWebView2::CapturePreview method.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_CAPTURE_PREVIEW_IMAGE_FORMAT {
    /// PNG image format.
    CORE_WEBVIEW2_CAPTURE_PREVIEW_IMAGE_FORMAT_PNG,
    /// JPEG image format.
    CORE_WEBVIEW2_CAPTURE_PREVIEW_IMAGE_FORMAT_JPEG,
  } CORE_WEBVIEW2_CAPTURE_PREVIEW_IMAGE_FORMAT;

  /// Kind of JavaScript dialog used in the ICoreWebView2ScriptDialogOpeningEventHandler
  /// interface.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_SCRIPT_DIALOG_KIND {
    /// A dialog invoked via the window.alert JavaScript function.
    CORE_WEBVIEW2_SCRIPT_DIALOG_KIND_ALERT,
    /// A dialog invoked via the window.confirm JavaScript function.
    CORE_WEBVIEW2_SCRIPT_DIALOG_KIND_CONFIRM,
    /// A dialog invoked via the window.prompt JavaScript function.
    CORE_WEBVIEW2_SCRIPT_DIALOG_KIND_PROMPT,
    /// A dialog invoked via the beforeunload JavaScript event.
    CORE_WEBVIEW2_SCRIPT_DIALOG_KIND_BEFOREUNLOAD,
  } CORE_WEBVIEW2_SCRIPT_DIALOG_KIND;

  /// Kind of process failure used in the ICoreWebView2ProcessFailedEventHandler interface.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_PROCESS_FAILED_KIND {
    /// Indicates the browser process terminated unexpectedly.
    /// The WebView automatically goes into the Closed state.
    /// The app has to recreate a new WebView to recover from this failure.
    CORE_WEBVIEW2_PROCESS_FAILED_KIND_BROWSER_PROCESS_EXITED,

    /// Indicates the render process terminated unexpectedly.
    /// A new render process will be created automatically and navigated to an
    /// error page.
    /// The app can use Reload to try to recover from this failure.
    CORE_WEBVIEW2_PROCESS_FAILED_KIND_RENDER_PROCESS_EXITED,

    /// Indicates the render process becomes unresponsive.
    /// The app can try to navigate away from the page to recover from the
    /// failure.
    // Note that this does not seem to work right now.
    // Does not fire for simple long running script case, the only related test
    // SitePerProcessBrowserTest::NoCommitTimeoutForInvisibleWebContents is
    // disabled.
    CORE_WEBVIEW2_PROCESS_FAILED_KIND_RENDER_PROCESS_UNRESPONSIVE,
  } CORE_WEBVIEW2_PROCESS_FAILED_KIND;

  /// The type of a permission request.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_PERMISSION_KIND {
    /// Unknown permission.
    CORE_WEBVIEW2_PERMISSION_KIND_UNKNOWN_PERMISSION,

    /// Permission to capture audio.
    CORE_WEBVIEW2_PERMISSION_KIND_MICROPHONE,

    /// Permission to capture video.
    CORE_WEBVIEW2_PERMISSION_KIND_CAMERA,

    /// Permission to access geolocation.
    CORE_WEBVIEW2_PERMISSION_KIND_GEOLOCATION,

    /// Permission to send web notifications.
    /// This permission request is currently auto rejected and
    /// no event is fired for it.
    CORE_WEBVIEW2_PERMISSION_KIND_NOTIFICATIONS,

    /// Permission to access generic sensor.
    /// Generic Sensor covering ambient-light-sensor, accelerometer, gyroscope
    /// and magnetometer.
    CORE_WEBVIEW2_PERMISSION_KIND_OTHER_SENSORS,

    /// Permission to read system clipboard without a user gesture.
    CORE_WEBVIEW2_PERMISSION_KIND_CLIPBOARD_READ,
  } CORE_WEBVIEW2_PERMISSION_KIND;

  /// Response to a permission request.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_PERMISSION_STATE {
    /// Use default browser behavior, which normally prompt users for decision.
    CORE_WEBVIEW2_PERMISSION_STATE_DEFAULT,

    /// Grant the permission request.
    CORE_WEBVIEW2_PERMISSION_STATE_ALLOW,

    /// Deny the permission request.
    CORE_WEBVIEW2_PERMISSION_STATE_DENY,
  } CORE_WEBVIEW2_PERMISSION_STATE;

  /// Error status values for web navigations.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_WEB_ERROR_STATUS {
    /// An unknown error occurred.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_UNKNOWN,

    /// The SSL certificate common name does not match the web address.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CERTIFICATE_COMMON_NAME_IS_INCORRECT,

    /// The SSL certificate has expired.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CERTIFICATE_EXPIRED,

    /// The SSL client certificate contains errors.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CLIENT_CERTIFICATE_CONTAINS_ERRORS,

    /// The SSL certificate has been revoked.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CERTIFICATE_REVOKED,

    /// The SSL certificate is invalid -- this could mean the certificate did not
    /// match the public key pins for the host name, the certificate is signed
    /// by an untrusted authority or using a weak sign algorithm, the
    /// certificate claimed DNS names violate name constraints, the certificate
    /// contains a weak key, the certificate's validity period is too long, lack
    /// of revocation information or revocation mechanism, non-unique host name,
    /// lack of certificate transparency information, or the certificate is
    /// chained to a [legacy Symantec
    /// root](https://security.googleblog.com/2018/03/distrust-of-symantec-pki-immediate.html).
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CERTIFICATE_IS_INVALID,

    /// The host is unreachable.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_SERVER_UNREACHABLE,

    /// The connection has timed out.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_TIMEOUT,

    /// The server returned an invalid or unrecognized response.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_ERROR_HTTP_INVALID_SERVER_RESPONSE,

    /// The connection was aborted.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CONNECTION_ABORTED,

    /// The connection was reset.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CONNECTION_RESET,

    /// The Internet connection has been lost.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_DISCONNECTED,

    /// Cannot connect to destination.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_CANNOT_CONNECT,

    /// Could not resolve provided host name.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_HOST_NAME_NOT_RESOLVED,

    /// The operation was canceled.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_OPERATION_CANCELED,

    /// The request redirect failed.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_REDIRECT_FAILED,

    /// An unexpected error occurred.
    CORE_WEBVIEW2_WEB_ERROR_STATUS_UNEXPECTED_ERROR,
  } CORE_WEBVIEW2_WEB_ERROR_STATUS;

  /// Enum for web resource request contexts.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT {
    /// All resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_ALL,
    /// Document resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_DOCUMENT,
    /// CSS resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_STYLESHEET,
    /// Image resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_IMAGE,
    /// Other media resources such as videos
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_MEDIA,
    /// Font resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_FONT,
    /// Script resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_SCRIPT,
    /// XML HTTP requests
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_XML_HTTP_REQUEST,
    /// Fetch API communication
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_FETCH,
    /// TextTrack resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_TEXT_TRACK,
    // EventSource API communication
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_EVENT_SOURCE,
    // WebSocket API communication
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_WEBSOCKET,
    // Web App Manifests
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_MANIFEST,
    // Signed HTTP Exchanges
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_SIGNED_EXCHANGE,
    // Ping requests
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_PING,
    // CSP Violation Reports
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_CSP_VIOLATION_REPORT,
    /// Other resources
    CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT_OTHER
  } CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT;

  /// The ICoreWebView2Settings object contains various modifiable settings for
  /// the running WebView.
  HRESULT get_Settings([out, retval] ICoreWebView2Settings** settings);

  /// The URI of the current top level document. This value potentially
  /// changes as a part of the SourceChanged event firing for some cases
  /// such as navigating to a different site or fragment navigations. It will
  /// remain the same for other types of navigations such as page reloads or
  /// history.pushState with the same URL as the current page.
  ///
  /// \snippet ControlComponent.cpp SourceChanged
  HRESULT get_Source([out, retval] LPWSTR* uri);

  /// Cause a navigation of the top level document to the specified URI. See
  /// the navigation events for more information. Note that this starts a
  /// navigation and the corresponding NavigationStarting event will fire
  /// sometime after this Navigate call completes.
  ///
  /// \snippet ControlComponent.cpp Navigate
  HRESULT Navigate([in] LPCWSTR uri);

  /// Initiates a navigation to htmlContent as source HTML of a new
  /// document. The htmlContent parameter may not be larger than 2 MB of
  /// characters. The origin of the new page will be about:blank.
  ///
  /// \snippet SettingsComponent.cpp NavigateToString
  HRESULT NavigateToString([in] LPCWSTR htmlContent);

  /// Add an event handler for the NavigationStarting event.
  /// NavigationStarting fires when the WebView main frame is
  /// requesting permission to navigate to a different URI. This will fire for
  /// redirects as well.
  ///
  /// \snippet SettingsComponent.cpp NavigationStarting
  HRESULT add_NavigationStarting(
      [in] ICoreWebView2NavigationStartingEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_NavigationStarting.
  HRESULT remove_NavigationStarting(
      [in] EventRegistrationToken token);

  /// Add an event handler for the ContentLoading event.
  /// ContentLoading fires before any content is loaded, including scripts added with
  /// AddScriptToExecuteOnDocumentCreated
  /// ContentLoading will not fire if a same page navigation occurs
  /// (such as through fragment navigations or history.pushState navigations).
  /// This follows the NavigationStarting and SourceChanged events and
  /// precedes the HistoryChanged and NavigationCompleted events.
  HRESULT add_ContentLoading(
      [in] ICoreWebView2ContentLoadingEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_ContentLoading.
  HRESULT remove_ContentLoading(
      [in] EventRegistrationToken token);

  /// SourceChanged fires when the Source property changes.
  /// SourceChanged fires for navigating to a different site or fragment navigations.
  /// It will not fires for other types of navigations such as page reloads or
  /// history.pushState with the same URL as the current page.
  /// SourceChanged fires before ContentLoading for navigation to a new document.
  /// Add an event handler for the SourceChanged event.
  /// \snippet ControlComponent.cpp SourceChanged
  HRESULT add_SourceChanged(
      [in] ICoreWebView2SourceChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_SourceChanged.
  HRESULT remove_SourceChanged(
      [in] EventRegistrationToken token);

  /// HistoryChange listen to the change of navigation history for the top level
  /// document. Use HistoryChange to check if get_CanGoBack/get_CanGoForward value
  /// has changed. HistoryChanged also fires for using GoBack/GoForward.
  /// HistoryChanged fires after SourceChanged and ContentLoading.
  /// Add an event handler for the HistoryChanged event.
  /// \snippet ControlComponent.cpp HistoryChanged
  HRESULT add_HistoryChanged(
      [in] ICoreWebView2HistoryChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_HistoryChanged.
  HRESULT remove_HistoryChanged(
      [in] EventRegistrationToken token);

  /// Add an event handler for the NavigationCompleted event.
  /// NavigationCompleted event fires when the WebView has completely loaded
  /// (body.onload has fired) or loading stopped with error.
  ///
  /// \snippet ControlComponent.cpp NavigationCompleted
  HRESULT add_NavigationCompleted(
      [in] ICoreWebView2NavigationCompletedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_NavigationCompleted.
  HRESULT remove_NavigationCompleted(
      [in] EventRegistrationToken token);

  /// Add an event handler for the FrameNavigationStarting event.
  /// FrameNavigationStarting fires when a child frame in the WebView
  /// requesting permission to navigate to a different URI. This will fire for
  /// redirects as well.
  ///
  /// \snippet SettingsComponent.cpp FrameNavigationStarting
  HRESULT add_FrameNavigationStarting(
      [in] ICoreWebView2NavigationStartingEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_FrameNavigationStarting.
  HRESULT remove_FrameNavigationStarting(
      [in] EventRegistrationToken token);

  /// Add an event handler for the ScriptDialogOpening event.
  /// The event fires when a JavaScript dialog (alert, confirm, or prompt) will
  /// show for the webview. This event only fires if the
  /// ICoreWebView2Settings::AreDefaultScriptDialogsEnabled property is set to
  /// false. The ScriptDialogOpening event can be used to suppress dialogs or
  /// replace default dialogs with custom dialogs.
  ///
  /// \snippet SettingsComponent.cpp ScriptDialogOpening
  HRESULT add_ScriptDialogOpening(
      [in] ICoreWebView2ScriptDialogOpeningEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_ScriptDialogOpening.
  HRESULT remove_ScriptDialogOpening(
      [in] EventRegistrationToken token);

  /// Add an event handler for the PermissionRequested event.
  /// Fires when content in a WebView requests permission to access some
  /// privileged resources.
  ///
  /// \snippet SettingsComponent.cpp PermissionRequested
  HRESULT add_PermissionRequested(
      [in] ICoreWebView2PermissionRequestedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_PermissionRequested.
  HRESULT remove_PermissionRequested(
      [in] EventRegistrationToken token);

  /// Add an event handler for the ProcessFailed event.
  /// Fires when a WebView process terminated unexpectedly or
  /// become unresponsive.
  ///
  /// \snippet ProcessComponent.cpp ProcessFailed
  HRESULT add_ProcessFailed(
      [in] ICoreWebView2ProcessFailedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_ProcessFailed.
  HRESULT remove_ProcessFailed(
      [in] EventRegistrationToken token);

  /// Add the provided JavaScript to a list of scripts
  /// that should be executed after the global object has been created, but
  /// before the HTML document has been parsed and before any other script
  /// included by the HTML document is executed. The
  /// injected script will apply to all future top level document and child
  /// frame navigations until removed with RemoveScriptToExecuteOnDocumentCreated.
  /// This is applied asynchronously and you must wait for the completion
  /// handler to run before you can be sure that the script is ready to
  /// execute on future navigations.
  ///
  /// Note that if an HTML document has sandboxing of some kind via [sandbox](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox)
  /// properties or the [Content-Security-Policy HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
  /// this will affect the script run here. So, for example, if the
  /// 'allow-modals' keyword is not set then calls to the `alert` function will
  /// be ignored.
  ///
  /// \snippet ScriptComponent.cpp AddScriptToExecuteOnDocumentCreated
  HRESULT AddScriptToExecuteOnDocumentCreated(
      [in] LPCWSTR javaScript,
      [in] ICoreWebView2AddScriptToExecuteOnDocumentCreatedCompletedHandler* handler);

  /// Remove the corresponding JavaScript added via AddScriptToExecuteOnDocumentCreated.
  HRESULT RemoveScriptToExecuteOnDocumentCreated([in] LPCWSTR id);

  /// Execute JavaScript code from the javascript parameter in the
  /// current top level document rendered in the WebView. This will execute
  /// asynchronously and when complete, if a handler is provided in the
  /// ExecuteScriptCompletedHandler parameter, its Invoke method will be
  /// called with the result of evaluating the provided JavaScript. The result
  /// value is a JSON encoded string.
  /// If the result is undefined, contains a reference cycle, or otherwise
  /// cannot be encoded into JSON, the JSON null value will be returned as the
  /// string 'null'. Note that a function that has no explicit return value
  /// returns undefined.
  /// If the executed script throws an unhandled exception, then the result is
  /// also 'null'.
  /// This method is applied asynchronously. If the call is made while the
  /// webview is on one document, and a navigation occurs after the call is
  /// made but before the JavaScript is executed, then the script will not be
  /// executed and the handler will be called with E_FAIL for its errorCode
  /// parameter.
  /// ExecuteScript will work even if IsScriptEnabled is set to FALSE.
  ///
  /// \snippet ScriptComponent.cpp ExecuteScript
  HRESULT ExecuteScript(
      [in] LPCWSTR javaScript,
      [in] ICoreWebView2ExecuteScriptCompletedHandler* handler);

  /// Capture an image of what WebView is displaying. Specify the
  /// format of the image with the imageFormat parameter.
  /// The resulting image binary data is written to the provided imageStream
  /// parameter. When CapturePreview finishes writing to the stream, the Invoke
  /// method on the provided handler parameter is called.
  ///
  /// \snippet FileComponent.cpp CapturePreview
  HRESULT CapturePreview(
      [in] CORE_WEBVIEW2_CAPTURE_PREVIEW_IMAGE_FORMAT imageFormat,
      [in] IStream* imageStream,
      [in] ICoreWebView2CapturePreviewCompletedHandler* handler);

  /// Reload the current page. This is similar to navigating to the URI of
  /// current top level document including all navigation events firing and
  /// respecting any entries in the HTTP cache. But, the back/forward history
  /// will not be modified.
  HRESULT Reload();

  /// Post the specified webMessage to the top level document in this WebView.
  /// The top level document's window.chrome.webview's message event fires.
  /// JavaScript in that document may subscribe and unsubscribe to the event
  /// via the following:
  /// ```
  ///    window.chrome.webview.addEventListener('message', handler)
  ///    window.chrome.webview.removeEventListener('message', handler)
  /// ```
  /// The event args is an instance of `MessageEvent`.
  /// The ICoreWebView2Settings::IsWebMessageEnabled setting must be true or this method
  /// will fail with E_INVALIDARG.
  /// The event arg's data property is the webMessage string parameter parsed
  /// as a JSON string into a JavaScript object.
  /// The event arg's source property is a reference to the
  /// `window.chrome.webview` object.
  /// See SetWebMessageReceivedEventHandler for information on sending messages
  /// from the HTML document in the webview to the host.
  /// This message is sent asynchronously. If a navigation occurs before the
  /// message is posted to the page, then the message will not be sent.
  ///
  /// \snippet ScenarioWebMessage.cpp WebMessageReceived
  HRESULT PostWebMessageAsJson([in] LPCWSTR webMessageAsJson);

  /// This is a helper for posting a message that is a simple string
  /// rather than a JSON string representation of a JavaScript object. This
  /// behaves in exactly the same manner as PostWebMessageAsJson but the
  /// `window.chrome.webview` message event arg's data property will be a string
  /// with the same value as webMessageAsString. Use this instead of
  /// PostWebMessageAsJson if you want to communicate via simple strings rather
  /// than JSON objects.
  HRESULT PostWebMessageAsString([in] LPCWSTR webMessageAsString);

  /// This event fires when the IsWebMessageEnabled setting is set and the top
  /// level document of the webview calls `window.chrome.webview.postMessage`.
  /// The postMessage function is `void postMessage(object)` where
  /// object is any object supported by JSON conversion.
  ///
  /// \snippet ScenarioWebMessage.html chromeWebView
  ///
  /// When postMessage is called, the ICoreWebView2WebMessageReceivedEventHandler set via
  /// this SetWebMessageReceivedEventHandler method will be invoked with the
  /// postMessage's object parameter converted to a JSON string.
  ///
  /// \snippet ScenarioWebMessage.cpp WebMessageReceived
  HRESULT add_WebMessageReceived(
      [in] ICoreWebView2WebMessageReceivedEventHandler* handler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_WebMessageReceived.
  HRESULT remove_WebMessageReceived(
      [in] EventRegistrationToken token);

  /// Call an asynchronous DevToolsProtocol method. See the
  /// [DevTools Protocol Viewer](https://aka.ms/DevToolsProtocolDocs)
  /// for a list and description of available methods.
  /// The methodName parameter is the full name of the method in the format
  /// `{domain}.{method}`.
  /// The parametersAsJson parameter is a JSON formatted string containing
  /// the parameters for the corresponding method.
  /// The handler's Invoke method will be called when the method asynchronously
  /// completes. Invoke will be called with the method's return object as a
  /// JSON string.
  ///
  /// \snippet ScriptComponent.cpp CallDevToolsProtocolMethod
  HRESULT CallDevToolsProtocolMethod(
      [in] LPCWSTR methodName,
      [in] LPCWSTR parametersAsJson,
      [in] ICoreWebView2CallDevToolsProtocolMethodCompletedHandler* handler);

  /// The process id of the browser process that hosts the WebView.
  HRESULT get_BrowserProcessId([out, retval] UINT32* value);

  /// Returns true if the webview can navigate to a previous page in the navigation history.
  /// The HistoryChanged event will fire if get_CanGoBack changes value.
  HRESULT get_CanGoBack([out, retval] BOOL* canGoBack);
  /// Returns true if the webview can navigate to a next page in the navigation history.
  /// The HistoryChanged event will fire if get_CanGoForward changes value.
  HRESULT get_CanGoForward([out, retval] BOOL* canGoForward);
  /// Navigates the WebView to the previous page in the navigation history.
  HRESULT GoBack();
  /// Navigates the WebView to the next page in the navigation history.
  HRESULT GoForward();

  /// Get a DevTools Protocol event receiver that allows you to subscribe to
  /// a DevTools Protocol event.
  /// The eventName parameter is the full name of the event in the format
  /// `{domain}.{event}`.
  /// See the [DevTools Protocol Viewer](https://aka.ms/DevToolsProtocolDocs)
  /// for a list of DevTools Protocol events description, and event args.
  ///
  /// \snippet ScriptComponent.cpp DevToolsProtocolEventReceived
  HRESULT GetDevToolsProtocolEventReceiver(
      [in] LPCWSTR eventName,
      [out, retval] ICoreWebView2DevToolsProtocolEventReceiver** receiver);

  /// Stop all navigations and pending resource fetches. Does not stop
  /// scripts.
  HRESULT Stop();

  /// Add an event handler for the NewWindowRequested event.
  /// Fires when content inside the WebView requested to open a new window,
  /// such as through window.open. The app can pass a target
  /// webview that will be considered the opened window.
  ///
  /// \snippet AppWindow.cpp NewWindowRequested
  HRESULT add_NewWindowRequested(
      [in] ICoreWebView2NewWindowRequestedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_NewWindowRequested.
  HRESULT remove_NewWindowRequested(
      [in] EventRegistrationToken token);

  /// Add an event handler for the DocumentTitleChanged event.
  /// The event fires when the DocumentTitle property of the WebView changes
  /// and may fire before or after the NavigationCompleted event.
  ///
  /// \snippet FileComponent.cpp DocumentTitleChanged
  HRESULT add_DocumentTitleChanged(
      [in] ICoreWebView2DocumentTitleChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_DocumentTitleChanged.
  HRESULT remove_DocumentTitleChanged(
      [in] EventRegistrationToken token);

  /// The title for the current top level document.
  /// If the document has no explicit title or is otherwise empty,
  /// a default that may or may not match the URI of the document will be used.
  HRESULT get_DocumentTitle([out, retval] LPWSTR* title);

  /// Add the provided host object to script running in the WebView with the
  /// specified name.
  /// Host objects are exposed as remote object proxies via
  /// `window.chrome.webview.remoteObjects.<name>`.
  /// Remote object proxies are promises and will resolve to an object
  /// representing the host object.
  /// The promise is rejected if the app has not added an object with the name.
  /// When JavaScript code access a property or method of the object, a promise
  /// is return, which will resolve to the value returned from the host for the
  /// property or method, or rejected in case of error such as there is no such
  /// property or method on the object or parameters are invalid.
  /// For example, when the application code does the following:
  /// ```
  ///    VARIANT object;
  ///    object.vt = VT_DISPATCH;
  ///    object.pdispVal = appObject;
  ///    webview->AddRemoteObject(L"host_object", &host);
  /// ```
  /// JavaScript code in the WebView will be able to access appObject as
  /// following and then access attributes and methods of appObject:
  /// ```
  ///    let app_object = await window.chrome.webview.remoteObjects.host_object;
  ///    let attr1 = await app_object.attr1;
  ///    let result = await app_object.method1(parameters);
  /// ```
  /// Note that while simple types, IDispatch and array are supported, generic
  /// IUnknown, VT_DECIMAL, or VT_RECORD variant is not supported.
  /// Remote JavaScript objects like callback functions are represented as
  /// an VT_DISPATCH VARIANT with the object implementing IDispatch. The
  /// JavaScript callback method may be invoked using DISPID_VALUE for the
  /// DISPID.
  /// Nested arrays are supported up to a depth of 3.
  /// Arrays of by reference types are not supported.
  /// VT_EMPTY and VT_NULL are mapped into JavaScript as null. In JavaScript
  /// null and undefined are mapped to VT_EMPTY.
  ///
  /// Additionally, all remote objects are exposed as
  /// `window.chrome.webview.remoteObjects.sync.<name>`. Here the host
  /// objects are exposed as synchronous remote object proxies. These are not
  /// promises and calls to functions or property access synchronously block
  /// running script waiting to communicate cross process for the host code to
  /// run. Accordingly this can result in reliability issues and it is
  /// recommended that you use the promise based asynchronous
  /// `window.chrome.webview.remoteObjects.<name>` API described above.
  ///
  /// Synchronous remote object proxies and asynchronous remote object proxies
  /// can both proxy the same remote object. Remote changes made by one proxy
  /// will be reflected in any other proxy of that same remote object whether
  /// the other proxies and synchronous or asynchronous.
  ///
  /// While JavaScript is blocked on a synchronous call to native code, that
  /// native code is unable to call back to JavaScript. Attempts to do so will
  /// fail with HRESULT_FROM_WIN32(ERROR_POSSIBLE_DEADLOCK).
  ///
  /// Remote object proxies are JavaScript Proxy objects that intercept all
  /// property get, property set, and method invocations. Properties or methods
  /// that are a part of the Function or Object prototype are run locally.
  /// Additionally any property or method in the array
  /// `chrome.webview.remoteObjects.options.forceLocalProperties` will also be
  /// run locally. This defaults to including optional methods that have
  /// meaning in JavaScript like `toJSON` and `Symbol.toPrimitive`. You can add
  /// more to this array as required.
  ///
  /// There's a method `chrome.webview.remoteObjects.cleanupSome` that will best
  /// effort garbage collect remote object proxies.
  ///
  /// Remote object proxies additionally have the following methods which run
  /// locally:
  ///  * applyRemote, getRemote, setRemote: Perform a method invocation,
  ///    property get, or property set on the remote object. You can use these
  ///    to explicitly force a method or property to run remotely if there is
  ///    a conflicting local method or property. For instance, `proxy.toString()`
  ///    will run the local toString method on the proxy object. But
  ///    ``proxy.applyRemote('toString')`` runs `toString` on the remote proxied
  ///    object instead.
  ///  * getLocal, setLocal: Perform property get, or property set locally. You
  ///    can use these methods to force getting or setting a property on the
  ///    remote object proxy itself rather than on the remote object it
  ///    represents. For instance, `proxy.unknownProperty` will get the
  ///    property named `unknownProperty` from the remote proxied object. But
  ///    ``proxy.getLocal('unknownProperty')`` will get the value of the property
  ///    `unknownProperty` on the proxy object itself.
  ///  * sync: Asynchronous remote object proxies expose a sync method which
  ///    returns a promise for a synchronous remote object proxy for the same
  ///    remote object. For example,
  ///    `chrome.webview.remoteObjects.sample.methodCall()` returns an
  ///    asynchronous remote object proxy. You can use the `sync` method to
  ///    obtain a synchronous remote object proxy instead:
  ///    `const syncProxy = await chrome.webview.remoteObjects.sample.methodCall().sync()`
  ///  * async: Synchronous remote object proxies expose an async method which
  ///    blocks and returns an asynchronous remote object proxy for the same
  ///    remote object. For example, `chrome.webview.remoteObjects.sync.sample.methodCall()` returns a
  ///    synchronous remote object proxy. Calling the `async` method on this blocks
  ///    and then returns an asynchronous remote object proxy for the same remote object:
  ///    `const asyncProxy = chrome.webview.remoteObjects.sync.sample.methodCall().async()`
  ///  * then: Asynchronous remote object proxies have a then method. This
  ///    allows them to be awaitable. `then` will return a promise that resolves
  ///    with a representation of the remote object. If the proxy represents a
  ///    JavaScript literal then a copy of that is returned locally. If
  ///    the proxy represents a function then a non-awaitable proxy is returned.
  ///    If the proxy represents a JavaScript object with a mix of literal
  ///    properties and function properties, then the a copy of the object is
  ///    returned with some properties as remote object proxies.
  ///
  /// All other property and method invocations (other than the above Remote
  /// object proxy methods, forceLocalProperties list, and properties on
  /// Function and Object prototypes) are run remotely. Asynchronous remote
  /// object proxies return a promise representing asynchronous completion of
  /// remotely invoking the method, or getting the property.
  /// The promise resolves after the remote operations complete and
  /// the promises resolve to the resulting value of the operation.
  /// Synchronous remote object proxies work similarly but block JavaScript
  /// execution and wait for the remote operation to complete.
  ///
  /// Setting a property on an asynchronous remote object proxy works slightly
  /// differently. The set returns immediately and the return value is the value
  /// that will be set. This is a requirement of the JavaScript Proxy object.
  /// If you need to asynchronously wait for the property set to complete, use
  /// the setRemote method which returns a promise as described above.
  /// Synchronous object property set property synchronously blocks until the
  /// property is set.
  ///
  /// For example, suppose you have a COM object with the following interface
  ///
  /// \snippet RemoteObjectSample.idl AddRemoteObjectInterface
  ///
  /// We can add an instance of this interface into our JavaScript with
  /// `AddRemoteObject`. In this case we name it `sample`:
  ///
  /// \snippet ScenarioAddRemoteObject.cpp AddRemoteObject
  ///
  /// Then in the HTML document we can use this COM object via `chrome.webview.remoteObjects.sample`:
  ///
  /// \snippet ScenarioAddRemoteObject.html RemoteObjectUsage
  HRESULT AddRemoteObject([in] LPCWSTR name, [in] VARIANT* object);

  /// Remove the host object specified by the name so that it is no longer
  /// accessible from JavaScript code in the WebView.
  /// While new access attempts will be denied, if the object is already
  /// obtained by JavaScript code in the WebView, the JavaScript code will
  /// continue to have access to that object.
  /// Calling this method for a name that is already removed or never added will
  /// fail.
  HRESULT RemoveRemoteObject([in] LPCWSTR name);

  /// Opens the DevTools window for the current document in the WebView.
  /// Does nothing if called when the DevTools window is already open
  HRESULT OpenDevToolsWindow();

  /// Notifies when the ContainsFullScreenElement property changes. This means
  /// that an HTML element inside the WebView is entering fullscreen to the size
  /// of the WebView or leaving fullscreen.
  /// This event is useful when, for example, a video element requests to go
  /// fullscreen. The listener of ContainsFullScreenElementChanged can then
  /// resize the WebView in response.
  ///
  /// \snippet AppWindow.cpp ContainsFullScreenElementChanged
  HRESULT add_ContainsFullScreenElementChanged(
      [in] ICoreWebView2ContainsFullScreenElementChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with the corresponding add_
  /// event method.
  HRESULT remove_ContainsFullScreenElementChanged(
      [in] EventRegistrationToken token);

  /// Indicates if the WebView contains a fullscreen HTML element.
  HRESULT get_ContainsFullScreenElement(
      [out, retval] BOOL* containsFullScreenElement);

  /// Add an event handler for the WebResourceRequested event. Fires when the
  /// WebView is performing an HTTP request to a matching URL and resource context
  /// filter that was added with AddWebResourceRequestedFilter. At least one
  /// filter must be added for the event to fire.
  ///
  /// \snippet SettingsComponent.cpp WebResourceRequested
  HRESULT add_WebResourceRequested(
    [in] ICoreWebView2WebResourceRequestedEventHandler* eventHandler,
    [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_WebResourceRequested.
  HRESULT remove_WebResourceRequested(
      [in] EventRegistrationToken token);

  /// Adds a URI and resource context filter to the WebResourceRequested event.
  /// URI parameter can be a wildcard string ('': zero or more, '?': exactly one).
  /// nullptr is equivalent to L"".
  /// See CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT enum for description of resource context filters.
  HRESULT AddWebResourceRequestedFilter(
    [in] LPCWSTR const uri,
    [in] CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT const resourceContext);
  /// Removes a matching WebResource filter that was previously added for the
  /// WebResourceRequested event. If the same filter was added multiple times, then it
  /// will need to be removed as many times as it was added for the removal to be
  /// effective. Returns E_INVALIDARG for a filter that was never added.
  HRESULT RemoveWebResourceRequestedFilter(
    [in] LPCWSTR const uri,
    [in] CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT const resourceContext);

  /// Add an event handler for the WindowCloseRequested event.
  /// Fires when content inside the WebView requested to close the window,
  /// such as after window.close is called. The app should close the WebView
  /// and related app window if that makes sense to the app.
  ///
  /// \snippet AppWindow.cpp WindowCloseRequested
  HRESULT add_WindowCloseRequested(
      [in] ICoreWebView2WindowCloseRequestedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_WindowCloseRequested.
  HRESULT remove_WindowCloseRequested(
      [in] EventRegistrationToken token);
}

/// This interface is the owner of the CoreWebView2 object, and provides support
/// for resizing, showing and hiding, focusing, and other functionality related
/// to windowing and composition. The CoreWebView2Host owns the CoreWebView2,
/// and if all references to the CoreWebView2Host go away, the WebView will
/// be closed.
[uuid(6ddf7138-a19b-4e55-8994-8a198b07f492), object, pointer_default(unique)]
interface ICoreWebView2Host : IUnknown {
  /// The IsVisible property determines whether to show or hide the webview.
  /// If IsVisible is set to false, the webview will be transparent and will
  /// not be rendered.  However, this will not affect the window containing
  /// the webview (the HWND parameter that was passed to CreateCoreWebView2Host).
  /// If you want that window to disappear too, call ShowWindow on it directly
  /// in addition to modifying the IsVisible property.
  /// WebView as a child window won't get window messages when the top window
  /// is minimized or restored. For performance reason, developer should set
  /// IsVisible property of the WebView to false when the app window is
  /// minimized and back to true when app window is restored. App window can do
  /// this by handling SC_MINIMIZE and SC_RESTORE command upon receiving
  /// WM_SYSCOMMAND message.
  ///
  /// \snippet ViewComponent.cpp ToggleIsVisible
  HRESULT get_IsVisible([out, retval] BOOL* isVisible);
  /// Set the IsVisible property.
  ///
  /// \snippet ViewComponent.cpp ToggleIsVisibleOnMinimize
  HRESULT put_IsVisible([in] BOOL isVisible);

  /// The webview bounds.
  /// Bounds are relative to the parent HWND. The app has two ways it can
  /// position a WebView:
  /// 1. Create a child HWND that is the WebView parent HWND. Position this
  ///    window where the WebView should be. In this case, use (0, 0) for the
  ///    WebView's Bound's top left corner (the offset).
  /// 2. Use the app's top most window as the WebView parent HWND. Set the
  ///    WebView's Bound's top left corner so that the WebView is positioned
  ///    correctly in the app.
  /// The Bound's values are in the host's coordinate space.
  HRESULT get_Bounds([out, retval] RECT* bounds);
  /// Set the Bounds property.
  ///
  /// \snippet ViewComponent.cpp ResizeWebView
  HRESULT put_Bounds([in] RECT bounds);

  /// The zoom factor for the WebView.
  /// Note that changing zoom factor could cause `window.innerWidth/innerHeight`
  /// and page layout to change.
  /// A zoom factor that is applied by the host by calling put_ZoomFactor
  /// becomes the new default zoom for the WebView. This zoom factor applies
  /// across navigations and is the zoom factor WebView is returned to when the
  /// user presses ctrl+0. When the zoom factor is changed by the user
  /// (resulting in the app receiving ZoomFactorChanged), that zoom applies
  /// only for the current page. Any user applied zoom is only for the current
  /// page and is reset on a navigation.
  /// Specifying a zoomFactor less than or equal to 0 is not allowed.
  /// WebView also has an internal supported zoom factor range. When a specified
  /// zoom factor is out of that range, it will be normalized to be within the
  /// range, and a ZoomFactorChanged event will be fired for the real
  /// applied zoom factor. When this range normalization happens, the
  /// ZoomFactor property will report the zoom factor specified during the
  /// previous modification of the ZoomFactor property until the
  /// ZoomFactorChanged event is received after webview applies the normalized
  /// zoom factor.
  HRESULT get_ZoomFactor([out, retval] double* zoomFactor);
  /// Set the ZoomFactor property.
  HRESULT put_ZoomFactor([in] double zoomFactor);

  /// Add an event handler for the ZoomFactorChanged event.
  /// The event fires when the ZoomFactor property of the WebView changes.
  /// The event could fire because the caller modified the ZoomFactor property,
  /// or due to the user manually modifying the zoom. When it is modified by the
  /// caller via the ZoomFactor property, the internal zoom factor is updated
  /// immediately and there will be no ZoomFactorChanged event.
  /// WebView associates the last used zoom factor for each site. Therefore, it
  /// is possible for the zoom factor to change when navigating to a different
  /// page. When the zoom factor changes due to this, the ZoomFactorChanged
  /// event fires right after the ContentLoading event.
  ///
  /// \snippet ViewComponent.cpp ZoomFactorChanged
  HRESULT add_ZoomFactorChanged(
      [in] ICoreWebView2ZoomFactorChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_ZoomFactorChanged.
  HRESULT remove_ZoomFactorChanged(
      [in] EventRegistrationToken token);

  /// Update Bounds and ZoomFactor properties at the same time. This operation
  /// is atomic from the host's perspecive. After returning from this function,
  /// the Bounds and ZoomFactor properties will have both been updated if the
  /// function is successful, or neither will be updated if the function fails.
  /// If Bounds and ZoomFactor are both updated by the same scale (i.e. Bounds
  /// and ZoomFactor are both doubled), then the page will not see a change in
  /// window.innerWidth/innerHeight and the WebView will render the content at
  /// the new size and zoom without intermediate renderings.
  /// This function can also be used to update just one of ZoomFactor or Bounds
  /// by passing in the new value for one and the current value for the other.
  ///
  /// \snippet ViewComponent.cpp SetBoundsAndZoomFactor
  HRESULT SetBoundsAndZoomFactor([in] RECT bounds, [in] double zoomFactor);

  /// Reason for moving focus.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_MOVE_FOCUS_REASON {
    /// Code setting focus into WebView.
    CORE_WEBVIEW2_MOVE_FOCUS_REASON_PROGRAMMATIC,

    /// Moving focus due to Tab traversal forward.
    CORE_WEBVIEW2_MOVE_FOCUS_REASON_NEXT,

    /// Moving focus due to Tab traversal backward.
    CORE_WEBVIEW2_MOVE_FOCUS_REASON_PREVIOUS,
  } CORE_WEBVIEW2_MOVE_FOCUS_REASON;

  /// Move focus into WebView. WebView will get focus and focus will be set to
  /// correspondent element in the page hosted in the WebView.
  /// For Programmatic reason, focus is set to previously focused element or
  /// the default element if there is no previously focused element.
  /// For Next reason, focus is set to the first element.
  /// For Previous reason, focus is set to the last element.
  /// WebView can also got focus through user interaction like clicking into
  /// WebView or Tab into it.
  /// For tabbing, the app can call MoveFocus with Next or Previous to align
  /// with tab and shift+tab respectively when it decides the WebView is the
  /// next tabbable element. Or, the app can call IsDialogMessage as part of
  /// its message loop to allow the platform to auto handle tabbing. The
  /// platform will rotate through all windows with WS_TABSTOP. When the
  /// WebView gets focus from IsDialogMessage, it will internally put the focus
  /// on the first or last element for tab and shift+tab respectively.
  ///
  /// \snippet App.cpp MoveFocus0
  ///
  /// \snippet ControlComponent.cpp MoveFocus1
  ///
  /// \snippet ControlComponent.cpp MoveFocus2
  HRESULT MoveFocus([in] CORE_WEBVIEW2_MOVE_FOCUS_REASON reason);

  /// Add an event handler for the MoveFocusRequested event.
  /// MoveFocusRequested fires when user tries to tab out of the WebView.
  /// The WebView's focus has not changed when this event is fired.
  ///
  /// \snippet ControlComponent.cpp MoveFocusRequested
  HRESULT add_MoveFocusRequested(
      [in] ICoreWebView2MoveFocusRequestedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_MoveFocusRequested.
  HRESULT remove_MoveFocusRequested(
      [in] EventRegistrationToken token);

  /// Add an event handler for the GotFocus event.
  /// GotFocus fires when WebView got focus.
  HRESULT add_GotFocus(
      [in] ICoreWebView2FocusChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_GotFocus.
  HRESULT remove_GotFocus(
      [in] EventRegistrationToken token);

  /// Add an event handler for the LostFocus event.
  /// LostFocus fires when WebView lost focus.
  /// In the case where MoveFocusRequested event is fired, the focus is still
  /// on WebView when MoveFocusRequested event fires. Lost focus only fires
  /// afterwards when app's code or default action of MoveFocusRequested event
  /// set focus away from WebView.
  HRESULT add_LostFocus(
      [in] ICoreWebView2FocusChangedEventHandler* eventHandler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_LostFocus.
  HRESULT remove_LostFocus(
      [in] EventRegistrationToken token);

  /// The type of key event that triggered an AcceleratorKeyPressed event.
  [v1_enum]
  typedef enum CORE_WEBVIEW2_KEY_EVENT_KIND {
    /// Correspond to window message WM_KEYDOWN.
    CORE_WEBVIEW2_KEY_EVENT_KIND_KEY_DOWN,

    /// Correspond to window message WM_KEYUP.
    CORE_WEBVIEW2_KEY_EVENT_KIND_KEY_UP,

    /// Correspond to window message WM_SYSKEYDOWN.
    CORE_WEBVIEW2_KEY_EVENT_KIND_SYSTEM_KEY_DOWN,

    /// Correspond to window message WM_SYSKEYUP.
    CORE_WEBVIEW2_KEY_EVENT_KIND_SYSTEM_KEY_UP,
  } CORE_WEBVIEW2_KEY_EVENT_KIND;

  /// A structure representing the information packed into the LPARAM given
  /// to a Win32 key event.  See the documentation for WM_KEYDOWN for details
  /// at https://docs.microsoft.com/windows/win32/inputdev/wm-keydown
  typedef struct CORE_WEBVIEW2_PHYSICAL_KEY_STATUS {
    /// The repeat count for the current message.
    UINT32 RepeatCount;
    /// The scan code.
    UINT32 ScanCode;
    /// Indicates whether the key is an extended key.
    BOOL IsExtendedKey;
    /// The context code.
    BOOL IsMenuKeyDown;
    /// The previous key state.
    BOOL WasKeyDown;
    /// The transition state.
    BOOL IsKeyReleased;
  } CORE_WEBVIEW2_PHYSICAL_KEY_STATUS;

  /// Add an event handler for the AcceleratorKeyPressed event.
  /// AcceleratorKeyPressed fires when an accelerator key or key combo is
  /// pressed or released while the WebView is focused. A key is considered an
  /// accelerator if either:
  ///   1. Ctrl or Alt is currently being held, or
  ///   2. the pressed key does not map to a character.
  /// A few specific keys are never considered accelerators, such as Shift.
  /// The Escape key is always considered an accelerator.
  ///
  /// Autorepeated key events caused by holding the key down will also fire this
  /// event.  You can filter these out by checking the event args'
  /// KeyEventLParam or PhysicalKeyStatus.
  ///
  /// In windowed mode, this event handler is called synchronously. Until you
  /// call Handle() on the event args or the event handler returns, the browser
  /// process will be blocked and outgoing cross-process COM calls will fail
  /// with RPC_E_CANTCALLOUT_ININPUTSYNCCALL. All CoreWebView2 API methods will
  /// work, however.
  ///
  /// In windowless mode, the event handler is called asynchronously.  Further
  /// input will not reach the browser until the event handler returns or
  /// Handle() is called, but the browser process itself will not be blocked,
  /// and outgoing COM calls will work normally.
  ///
  /// It is recommended to call Handle(TRUE) as early as you can know that you want
  /// to handle the accelerator key.
  ///
  /// \snippet ControlComponent.cpp AcceleratorKeyPressed
  HRESULT add_AcceleratorKeyPressed(
    [in] ICoreWebView2AcceleratorKeyPressedEventHandler* eventHandler,
    [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with add_AcceleratorKeyPressed.
  HRESULT remove_AcceleratorKeyPressed(
    [in] EventRegistrationToken token);

  /// The parent window provided by the app that this WebView is using to
  /// render content. This API initially returns the window passed into
  /// CreateCoreWebView2Host.
  HRESULT get_ParentWindow([out, retval] HWND* topLevelWindow);

  /// Set the parent window for the WebView. This will cause the WebView to
  /// reparent its window to the newly provided window.
  HRESULT put_ParentWindow([in] HWND topLevelWindow);

  /// This is a notification separate from put_Bounds that tells WebView its
  /// parent (or any ancestor) HWND moved. This is needed for accessibility and
  /// certain dialogs in WebView to work correctly.
  /// \snippet AppWindow.cpp NotifyParentWindowPositionChanged
  HRESULT NotifyParentWindowPositionChanged();

  /// Closes the WebView and cleans up the underlying browser instance.
  /// Cleaning up the browser instace will release the resources powering the WebView.
  /// The browser instance will be shut down if there are no other WebViews using it.
  ///
  /// After calling Close, all method calls will fail and event handlers
  /// will stop firing. Specifically, the WebView will release its references
  /// to its event handlers when Close is called.
  ///
  /// Close is implicitly called when the CoreWebView2Host loses its final
  /// reference and is destructed. But it is best practice to explicitly call
  /// Close to avoid any accidental cycle of references between the WebView
  /// and the app code. Specifically, if you capture a reference to the WebView
  /// in an event handler you will create a reference cycle between the WebView
  /// and the event handler. Calling Close will break this cycle by releasing
  /// all event handlers. But to avoid this situation it is best practice both
  /// to explicitly call Close on the WebView and to not capture a reference to
  /// the WebView to ensure the WebView can be cleaned up correctly.
  ///
  /// \snippet AppWindow.cpp Close
  HRESULT Close();

  /// Gets the CoreWebView2 associated with this CoreWebView2Host.
  HRESULT get_CoreWebView2([out, retval] ICoreWebView2** coreWebView2);
}

/// This interface is used to complete deferrals on event args that
/// support getting deferrals via their GetDeferral method.
[uuid(C1000D7C-4817-40EB-A2AE-3B929D5A8EE3), object, pointer_default(unique)]
interface ICoreWebView2Deferral : IUnknown {
  /// Completes the associated deferred event. Complete should only be
  /// called once for each deferral taken.
  HRESULT Complete();
}

/// Defines properties that enable, disable, or modify WebView
/// features. Setting changes made after NavigationStarting event will not
/// apply until the next top level navigation.
[uuid(D58A964A-13C4-44FB-81AD-64AE242E9ADC), object, pointer_default(unique)]
interface ICoreWebView2Settings : IUnknown {
  /// Controls if JavaScript execution is enabled in all future
  /// navigations in the WebView.  This only affects scripts in the document;
  /// scripts injected with ExecuteScript will run even if script is disabled.
  /// It is true by default.
  ///
  /// \snippet SettingsComponent.cpp IsScriptEnabled
  HRESULT get_IsScriptEnabled(
      [out, retval] BOOL* isScriptEnabled);
  /// Set the IsScriptEnabled property.
  HRESULT put_IsScriptEnabled([in] BOOL isScriptEnabled);

  /// The IsWebMessageEnabled property is used when loading a new
  /// HTML document. If set to true, communication from the host to the
  /// webview's top level HTML document is allowed via PostWebMessageAsJson,
  /// PostWebMessageAsString, and window.chrome.webview's message event
  /// (see PostWebMessageAsJson documentation for details).
  /// Communication from the webview's top level HTML document
  /// to the host is allowed via window.chrome.webview's postMessage function
  /// and the SetWebMessageReceivedEventHandler method (see the
  /// SetWebMessageReceivedEventHandler documentation for details).
  /// If set to false, then communication is disallowed.
  /// PostWebMessageAsJson and PostWebMessageAsString will
  /// fail with E_ACCESSDENIED and window.chrome.webview.postMessage will fail
  /// by throwing an instance of an Error object.
  /// It is true by default.
  ///
  /// \snippet ScenarioWebMessage.cpp IsWebMessageEnabled
  HRESULT get_IsWebMessageEnabled(
      [out, retval] BOOL* isWebMessageEnabled);
  /// Set the IsWebMessageEnabled property.
  HRESULT put_IsWebMessageEnabled([in] BOOL isWebMessageEnabled);

  /// AreDefaultScriptDialogsEnabled is used when loading a new
  /// HTML document. If set to false, then WebView won't render the default
  /// javascript dialog box (Specifically those shown by the javascript alert,
  /// confirm, prompt functions and beforeunload event). Instead, if an event
  /// handler is set by SetScriptDialogOpeningEventHandler, WebView will send an
  /// event that will contain all of the information for the dialog and allow
  /// the host app to show its own custom UI.
  HRESULT get_AreDefaultScriptDialogsEnabled(
      [out, retval] BOOL* areDefaultScriptDialogsEnabled);
  /// Set the AreDefaultScriptDialogsEnabled property.
  HRESULT put_AreDefaultScriptDialogsEnabled(
      [in] BOOL areDefaultScriptDialogsEnabled);

  /// IsStatusBarEnabled controls whether the status bar will be displayed. The
  /// status bar is usually displayed in the lower left of the WebView and shows
  /// things such as the URI of a link when the user hovers over it and other
  /// information. It is true by default.
  HRESULT get_IsStatusBarEnabled([out, retval] BOOL* isStatusBarEnabled);
  /// Set the IsStatusBarEnabled property.
  HRESULT put_IsStatusBarEnabled([in] BOOL isStatusBarEnabled);

  /// AreDevToolsEnabled controls whether the user is able to use the context
  /// menu or keyboard shortcuts to open the DevTools window.
  /// It is true by default.
  HRESULT get_AreDevToolsEnabled([out, retval] BOOL* areDevToolsEnabled);
  /// Set the AreDevToolsEnabled property.
  HRESULT put_AreDevToolsEnabled([in] BOOL areDevToolsEnabled);

  /// The AreDefaultContextMenusEnabled property is used to prevent
  /// default context menus from being shown to user in webview. Defaults to TRUE.
  ///
  /// \snippet SettingsComponent.cpp DisableContextMenu
  HRESULT get_AreDefaultContextMenusEnabled([out, retval] BOOL* enabled);
  /// Set the AreDefaultContextMenusEnabled property
  HRESULT put_AreDefaultContextMenusEnabled([in] BOOL enabled);

  /// The AreRemoteObjectsAllowed property is used to control whether
  /// remote objects are accessible from the page in webview. Defaults to TRUE.
  ///
  /// \snippet SettingsComponent.cpp RemoteObjectsAccess
  HRESULT get_AreRemoteObjectsAllowed([out, retval] BOOL* allowed);
  /// Set the AreRemoteObjectsAllowed property
  HRESULT put_AreRemoteObjectsAllowed([in] BOOL allowed);

  /// The IsZoomControlEnabled property is used to prevent the user from
  /// impacting the zoom of the WebView. Defaults to TRUE.
  /// When disabled, user will not be able to zoom using ctrl+/- or
  /// ctrl+mouse wheel, but the zoom can be set via put_ZoomFactor API.
  ///
  /// \snippet SettingsComponent.cpp DisableZoomControl
  HRESULT get_IsZoomControlEnabled([out, retval] BOOL* enabled);
  /// Set the IsZoomControlEnabled property
  HRESULT put_IsZoomControlEnabled([in] BOOL enabled);
}

/// Event args for the ProcessFailed event.
[uuid(9E354785-CFA2-480A-84E0-57837ADD8E36), object, pointer_default(unique)]
interface ICoreWebView2ProcessFailedEventArgs : IUnknown {
  /// The kind of process failure that has occurred.
  HRESULT get_ProcessFailedKind(
      [out, retval] CORE_WEBVIEW2_PROCESS_FAILED_KIND* processFailedKind);
}

/// The caller implements this interface to receive ProcessFailed events.
[uuid(A85C66A9-DE47-47F7-AD64-ABB32F1CF14D), object, pointer_default(unique)]
interface ICoreWebView2ProcessFailedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2ProcessFailedEventArgs* args);
}

/// The caller implements this interface to receive ZoomFactorChanged
/// events. Use the ICoreWebView2Host.ZoomFactor property to get the
/// modified zoom factor.
[uuid(1B03A40F-92B7-443A-87E0-B65714B6CB9D), object, pointer_default(unique)]
interface ICoreWebView2ZoomFactorChangedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event. There are no event args and the args
  /// parameter will be null.
  HRESULT Invoke([in] ICoreWebView2Host* sender, [in] IUnknown* args);
}

/// Iterator for a collection of HTTP headers. See ICoreWebView2HttpRequestHeaders
/// and ICoreWebView2HttpResponseHeaders.
/// \snippet ScenarioWebViewEventMonitor.cpp HttpRequestHeaderIterator
[uuid(B0F8A736-CC49-4414-BB9C-FDBC02599622), object, pointer_default(unique)]
interface ICoreWebView2HttpHeadersCollectionIterator : IUnknown {
  /// Get the name and value of the current HTTP header of the iterator. This
  /// method will fail if the last call to MoveNext set has_next to FALSE.
  HRESULT GetCurrentHeader([out] LPWSTR* name, [out] LPWSTR* value);

  /// True when the iterator hasn't run out of headers. If the collection over
  /// which the iterator is iterating is empty or if the iterator has gone past
  /// the end of the collection then this is false.
  HRESULT get_HasCurrentHeader([out, retval] BOOL* hasCurrent);

  /// Move the iterator to the next HTTP header in the collection. The hasNext
  /// parameter will be set to FALSE if there are no more HTTP headers. After
  /// this occurs the GetCurrentHeader method will fail if called.
  HRESULT MoveNext([out] BOOL* hasNext);
}

/// HTTP request headers. Used to inspect the HTTP request on
/// WebResourceRequested event and NavigationStarting event.
/// Note, you can modify the HTTP request headers from a WebResourceRequested event,
/// but not from a NavigationStarting event.
[uuid(160B895B-D0AF-4A42-A14F-5571CFA68B03), object, pointer_default(unique)]
interface ICoreWebView2HttpRequestHeaders : IUnknown {
  /// Gets the header value matching the name.
  HRESULT GetHeader([in] LPCWSTR name, [out, retval] LPWSTR* value);
  /// Gets the header value matching the name via an iterator.
  HRESULT GetHeaders([in] LPCWSTR name, [out, retval] ICoreWebView2HttpHeadersCollectionIterator** iterator);
  /// Checks whether the headers contain an entry matching the header name.
  HRESULT Contains([in] LPCWSTR name, [out, retval] BOOL* contains);
  /// Adds or updates header that matches the name.
  HRESULT SetHeader([in] LPCWSTR name, [in] LPCWSTR value);
  /// Removes header that matches the name.
  HRESULT RemoveHeader([in] LPCWSTR name);
  /// Gets an iterator over the collection of request headers.
  HRESULT GetIterator(
      [out, retval] ICoreWebView2HttpHeadersCollectionIterator** iterator);
}

/// HTTP response headers. Used to construct a WebResourceResponse for the
/// WebResourceRequested event.
[uuid(3E81928E-DDAE-4B3C-BCEF-DB2752BCFA1E), object, pointer_default(unique)]
interface ICoreWebView2HttpResponseHeaders : IUnknown {
  /// Appends header line with name and value.
  HRESULT AppendHeader([in] LPCWSTR name, [in] LPCWSTR value);
  /// Checks whether the headers contain entries matching the header name.
  HRESULT Contains([in] LPCWSTR name, [out, retval] BOOL* contains);
  /// Gets the first header value in the collection matching the name.
  HRESULT GetHeader([in] LPCWSTR name, [out, retval] LPWSTR* value);
  /// Gets the header values matching the name.
  HRESULT GetHeaders([in] LPCWSTR name, [out, retval] ICoreWebView2HttpHeadersCollectionIterator** iterator);
  /// Gets an iterator over the collection of entire response headers.
  HRESULT GetIterator(
  [out, retval] ICoreWebView2HttpHeadersCollectionIterator** iterator);
}

/// An HTTP request used with the WebResourceRequested event.
[uuid(7471A125-D5E8-45A8-B119-F9E9230D4D0B), object, pointer_default(unique)]
interface ICoreWebView2WebResourceRequest : IUnknown {
  /// The request URI.
  HRESULT get_Uri([out, retval] LPWSTR* uri);
  /// Set the Uri property.
  HRESULT put_Uri([in] LPCWSTR uri);

  /// The HTTP request method.
  HRESULT get_Method([out, retval] LPWSTR* method);
  /// Set the Method property.
  HRESULT put_Method([in] LPCWSTR method);

  /// The HTTP request message body as stream. POST data would be here.
  /// If a stream is set, which will override the message body, the stream must
  /// have all the content data available by the time this
  /// response's WebResourceRequested event deferral is completed. Stream
  /// should be agile or be created from a background STA to prevent performance
  /// impact to the UI thread. Null means no content data. IStream semantics
  /// apply (return S_OK to Read calls until all data is exhausted)
  HRESULT get_Content([out, retval] IStream** content);
  /// Set the Content property.
  HRESULT put_Content([in] IStream* content);

  /// The mutable HTTP request headers
  HRESULT get_Headers([out, retval] ICoreWebView2HttpRequestHeaders** headers);
}

/// An HTTP response used with the WebResourceRequested event.
[uuid(2B842125-E3B4-40A2-8BB8-C31AABF70E0A), object, pointer_default(unique)]
interface ICoreWebView2WebResourceResponse : IUnknown {
  /// HTTP response content as stream. Stream must have all the
  /// content data available by the time this response's WebResourceRequested
  /// event deferral is completed. Stream should be agile or be created from
  /// a background thread to prevent performance impact to the UI thread.
  /// Null means no content data. IStream semantics
  /// apply (return S_OK to Read calls until all data is exhausted)
  HRESULT get_Content([out, retval] IStream** content);
  /// Set the Content property.
  HRESULT put_Content([in] IStream* content);

  /// Overridden HTTP response headers.
  HRESULT get_Headers([out, retval] ICoreWebView2HttpResponseHeaders** headers);

  /// The HTTP response status code.
  HRESULT get_StatusCode([out, retval] int* statusCode);
  /// Set the StatusCode property.
  HRESULT put_StatusCode([in] int statusCode);

  /// The HTTP response reason phrase
  HRESULT get_ReasonPhrase([out, retval] LPWSTR* reasonPhrase);
  /// Set the ReasonPhrase property.
  HRESULT put_ReasonPhrase([in] LPCWSTR reasonPhrase);
}

/// Event args for the NavigationStarting event.
[uuid(1C81A448-575B-44A1-9ABD-1B93A3DE9E03), object, pointer_default(unique)]
interface ICoreWebView2NavigationStartingEventArgs : IUnknown {
  /// The uri of the requested navigation.
  HRESULT get_Uri([out, retval] LPWSTR* uri);

  /// True when the navigation was initiated through a user gesture as opposed
  /// to programmatic navigation.
  HRESULT get_IsUserInitiated([out, retval] BOOL* isUserInitiated);

  /// True when the navigation is redirected.
  HRESULT get_IsRedirected([out, retval] BOOL* isRedirected);

  /// The HTTP request headers for the navigation.
  /// Note, you cannot modify the HTTP request headers in a NavigationStarting event.
  HRESULT get_RequestHeaders([out, retval] ICoreWebView2HttpRequestHeaders** requestHeaders);

  /// The host may set this flag to cancel the navigation.
  /// If set, it will be as if the navigation never happened and the current
  /// page's content will be intact. For performance reasons, GET HTTP requests
  /// may happen, while the host is responding. This means cookies can be set
  /// and used part of a request for the navigation.
  HRESULT get_Cancel([out, retval] BOOL* cancel);
  /// Set the Cancel property.
  HRESULT put_Cancel([in] BOOL cancel);

  /// The ID of the navigation.
  HRESULT get_NavigationId([out, retval] UINT64* navigation_id);
}

/// The caller implements this interface to receive the NavigationStarting
/// event.
[uuid(CD2F4CAE-BA09-47F3-94EE-A785CEC7C907), object, pointer_default(unique)]
interface ICoreWebView2NavigationStartingEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2NavigationStartingEventArgs* args);
}

/// Event args for the ContentLoading event.
[uuid(696ED8C1-4657-4769-928F-10EF8040ED25), object, pointer_default(unique)]
interface ICoreWebView2ContentLoadingEventArgs : IUnknown {
  /// True if the loaded content is an error page.
  HRESULT get_IsErrorPage([out, retval] BOOL* isErrorPage);

  /// The ID of the navigation.
  HRESULT get_NavigationId([out, retval] UINT64* navigation_id);
}

/// The caller implements this interface to receive the ContentLoading event.
[uuid(70057D5C-0BAA-4219-97B0-FFF1C088ED32), object, pointer_default(unique)]
interface ICoreWebView2ContentLoadingEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke([in] ICoreWebView2* webview, [in] ICoreWebView2ContentLoadingEventArgs* args);
}

/// Event args for the SourceChanged event.
[uuid(26D4B817-9496-4F67-AEAB-24EB38482037), object, pointer_default(unique)]
interface ICoreWebView2SourceChangedEventArgs : IUnknown {
  /// True if the page being navigated to is a new document.
  HRESULT get_IsNewDocument([out, retval] BOOL* isNewDocument);
}

/// The caller implements this interface to receive the SourceChanged event.
[uuid(E345159A-B573-41AB-A4F7-F94CB238AF45), object, pointer_default(unique)]
interface ICoreWebView2SourceChangedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke([in] ICoreWebView2* webview, [in] ICoreWebView2SourceChangedEventArgs* args);
}

/// The caller implements this interface to receive the HistoryChanged event.
[uuid(29211B19-F775-48CC-9757-5DA3CA1F626A), object, pointer_default(unique)]
interface ICoreWebView2HistoryChangedEventHandler : IUnknown {
  /// There are no event args and the args parameter will be null.
  HRESULT Invoke([in] ICoreWebView2* webview, [in] IUnknown* args);
}

/// Event args for the ScriptDialogOpening event.
[uuid(49C08E35-FCE1-4C6A-8DBD-6F58666C0CBE), object, pointer_default(unique)]
interface ICoreWebView2ScriptDialogOpeningEventArgs : IUnknown {
  /// The URI of the page that requested the dialog box.
  HRESULT get_Uri([out, retval] LPWSTR* uri);

  /// The kind of JavaScript dialog box. Accept, confirm, prompt, or
  /// beforeunload.
  HRESULT get_Kind([out, retval] CORE_WEBVIEW2_SCRIPT_DIALOG_KIND* kind);

  /// The message of the dialog box. From JavaScript this is the first parameter
  /// passed to alert, confirm, and prompt and is empty for beforeunload.
  HRESULT get_Message([out, retval] LPWSTR* message);

  /// The host may call this to respond with OK to confirm, prompt, and
  /// beforeunload dialogs or not call this method to indicate cancel. From
  /// JavaScript, this means that the confirm and beforeunload function returns
  /// true if Accept is called. And for the prompt function it returns the value
  /// of ResultText if Accept is called and returns false otherwise.
  HRESULT Accept();

  /// The second parameter passed to the JavaScript prompt dialog. This is the
  /// the default value to use for the result of the prompt JavaScript function.
  HRESULT get_DefaultText([out, retval] LPWSTR* defaultText);

  /// The return value from the JavaScript prompt function if Accept is called.
  /// This is ignored for dialog kinds other than prompt. If Accept is not
  /// called this value is ignored and false is returned from prompt.
  HRESULT get_ResultText([out, retval] LPWSTR* resultText);
  /// Set the ResultText property.
  HRESULT put_ResultText([in] LPCWSTR resultText);

  /// GetDeferral can be called to return an ICoreWebView2Deferral object.
  /// You can use this to complete the event at a later time.
  HRESULT GetDeferral([out, retval] ICoreWebView2Deferral** deferral);
}

/// The caller implements this interface to receive the ScriptDialogOpening
/// event.
[uuid(E4CDFD7A-AA15-4738-8A8F-4C8C28A9BAC1), object, pointer_default(unique)]
interface ICoreWebView2ScriptDialogOpeningEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2ScriptDialogOpeningEventArgs* args);
}

/// Event args for the NavigationCompleted event.
[uuid(1337EED4-BC5B-48FB-9672-80D18733CFD5), object, pointer_default(unique)]
interface ICoreWebView2NavigationCompletedEventArgs : IUnknown {
  /// True when the navigation is successful. This
  /// is false for a navigation that ended up in an error page (failures due to
  /// no network, DNS lookup failure, HTTP server responds with 4xx), but could
  /// also be false for additional things such as window.stop() called on
  /// navigated page.
  HRESULT get_IsSuccess([out, retval] BOOL* isSuccess);

  /// The error code if the navigation failed.
  HRESULT get_WebErrorStatus([out, retval] CORE_WEBVIEW2_WEB_ERROR_STATUS*
      CORE_WEBVIEW2_WEB_ERROR_STATUS);

  /// The ID of the navigation.
  HRESULT get_NavigationId([out, retval] UINT64* navigation_id);
}

/// The caller implements this interface to receive the NavigationCompleted
/// event.
[uuid(17EB2F75-B65B-4E5F-A0E1-933126DDD5BB), object, pointer_default(unique)]
interface ICoreWebView2NavigationCompletedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2NavigationCompletedEventArgs* args);
}

/// Event args for the PermissionRequested event.
[uuid(DBB6C9C9-FBB5-40FD-8843-5BE65807FD8A), object, pointer_default(unique)]
interface ICoreWebView2PermissionRequestedEventArgs : IUnknown {
  /// The origin of the web content that requests the permission.
  HRESULT get_Uri([out, retval] LPWSTR* uri);

  /// The type of the permission that is requested.
  HRESULT get_PermissionKind([out, retval] CORE_WEBVIEW2_PERMISSION_KIND* value);

  /// True when the permission request was initiated through a user gesture.
  /// Note that being initiated through a user gesture doesn't mean that user
  /// intended to access the associated resource.
  HRESULT get_IsUserInitiated([out, retval] BOOL* isUserInitiated);

  /// The status of a permission request, i.e. whether the request is granted.
  /// Default value is CORE_WEBVIEW2_PERMISSION_STATE_DEFAULT.
  HRESULT get_State([out, retval] CORE_WEBVIEW2_PERMISSION_STATE* value);
  /// Set the State property.
  HRESULT put_State([in] CORE_WEBVIEW2_PERMISSION_STATE value);

  /// GetDeferral can be called to return an ICoreWebView2Deferral object.
  /// Developer can use the deferral object to make the permission decision
  /// at a later time.
  HRESULT GetDeferral([out, retval] ICoreWebView2Deferral** deferral);
}

/// The caller implements this interface to receive the PermissionRequested
/// event.
[uuid(7079A1F0-CF14-4046-8E26-46BF54163673), object, pointer_default(unique)]
interface ICoreWebView2PermissionRequestedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2PermissionRequestedEventArgs* args);
}

/// The caller implements this interface to receive the result of the
/// AddScriptToExecuteOnDocumentCreated method.
[uuid(8889C588-9DC7-4266-9BB3-369AFDDE2A7F), object, pointer_default(unique)]
interface ICoreWebView2AddScriptToExecuteOnDocumentCreatedCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status and result
  /// of the corresponding asynchronous method call.
  HRESULT Invoke([in] HRESULT errorCode, [in] LPCWSTR id);
}

/// The caller implements this interface to receive the result of the
/// ExecuteScript method.
[uuid(51457AE2-93FD-404E-A957-3D6034EAD733), object, pointer_default(unique)]
interface ICoreWebView2ExecuteScriptCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status and result
  /// of the corresponding asynchronous method call.
  HRESULT Invoke([in] HRESULT errorCode, [in] LPCWSTR resultObjectAsJson);
}

/// Event args for the WebResourceRequested event.
[uuid(6EF9912F-5A9D-42A9-8C17-9BB53E1D5C63), object, pointer_default(unique)]
interface ICoreWebView2WebResourceRequestedEventArgs : IUnknown
{
  /// The HTTP request.
  HRESULT get_Request([out, retval] ICoreWebView2WebResourceRequest** request);

  /// The HTTP response.
  HRESULT get_Response([out, retval] ICoreWebView2WebResourceResponse** response);
  /// Set the Response property.
  HRESULT put_Response([in] ICoreWebView2WebResourceResponse* response);

  /// Obtain an ICoreWebView2Deferral object and put the event into a deferred state.
  /// You can use the ICoreWebView2Deferral object to complete the network request at a
  /// later time.
  HRESULT GetDeferral([out, retval] ICoreWebView2Deferral** deferral);

  /// The web resource request contexts.
  HRESULT get_ResourceContext([out, retval] CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT* context);
}

/// Fires when an HTTP request is made in the webview. The host can override
/// request, response headers and response content.
[uuid(A8DC0663-3C2C-4190-8129-5F1F598CA7B8), object, pointer_default(unique)]
interface ICoreWebView2WebResourceRequestedEventHandler : IUnknown
{
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2WebResourceRequestedEventArgs* args);
}

/// The caller implements this method to receive the result of the
/// CapturePreview method. The result is written to the stream provided in
/// the CapturePreview method call.
[uuid(A1A2EC1C-B5C3-4EB2-9BCB-9166AFAA0E85), object, pointer_default(unique)]
interface ICoreWebView2CapturePreviewCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status
  /// of the corresponding asynchronous method call.
  HRESULT Invoke([in] HRESULT result);
}

/// The caller implements this method to receive the GotFocus and LostFocus
/// events. There are no event args for this event.
[uuid(19F31771-9BB5-422B-9A0A-6EDDAF4FFE0F), object, pointer_default(unique)]
interface ICoreWebView2FocusChangedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event. There are no event args and the args
  /// parameter will be null.
  HRESULT Invoke(
      [in] ICoreWebView2Host* sender,
      [in] IUnknown* args);
}

/// Event args for the MoveFocusRequested event.
[uuid(CE31A597-E202-49B9-A9BE-825481ED517E), object, pointer_default(unique)]
interface ICoreWebView2MoveFocusRequestedEventArgs : IUnknown {
  /// The reason for WebView to fire the MoveFocus Requested event.
  HRESULT get_Reason([out, retval] CORE_WEBVIEW2_MOVE_FOCUS_REASON* value);

  /// Indicate whether the event has been handled by the app.
  /// If the app has moved the focus to its desired location, it should set
  /// Handled property to TRUE.
  /// When Handled property is false after the event handler returns, default
  /// action will be taken. The default action is to try to find the next tab
  /// stop child window in the app and try to move focus to that window. If
  /// there is no other such window to move focus to, focus will be cycled
  /// within the WebView's web content.
  HRESULT get_Handled([out, retval] BOOL* value);
  /// Set the Handled property.
  HRESULT put_Handled([in] BOOL value);
}

/// The caller implements this method to receive the MoveFocusRequested event.
[uuid(01BA7131-3DBE-4C83-A789-99C467A2C3F5), object, pointer_default(unique)]
interface ICoreWebView2MoveFocusRequestedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2Host* sender,
      [in] ICoreWebView2MoveFocusRequestedEventArgs* args);
}

/// Event args for the WebMessageReceived event.
[uuid(B21D70E2-942E-44EB-B843-22C156FDE288), object, pointer_default(unique)]
interface ICoreWebView2WebMessageReceivedEventArgs : IUnknown {
  /// The URI of the document that sent this web message.
  HRESULT get_Source([out, retval] LPWSTR* source);

  /// The message posted from the webview content to the host converted to a
  /// JSON string. Use this to communicate via JavaScript objects.
  ///
  /// For example the following postMessage calls result in the
  /// following WebMessageAsJson values:
  ///
  /// ```
  ///    postMessage({'a': 'b'})      L"{\"a\": \"b\"}"
  ///    postMessage(1.2)             L"1.2"
  ///    postMessage('example')       L"\"example\""
  /// ```
  HRESULT get_WebMessageAsJson([out, retval] LPWSTR* webMessageAsJson);

  /// If the message posted from the webview content to the host is a
  /// string type, this method will return the value of that string. If the
  /// message posted is some other kind of JavaScript type this method will fail
  /// with E_INVALIDARG. Use this to communicate via simple strings.
  ///
  /// For example the following postMessage calls result in the
  /// following WebMessageAsString values:
  ///
  /// ```
  ///    postMessage({'a': 'b'})      E_INVALIDARG
  ///    postMessage(1.2)             E_INVALIDARG
  ///    postMessage('example')       L"example"
  /// ```
  HRESULT TryGetWebMessageAsString([out, retval] LPWSTR* webMessageAsString);
}

/// The caller implements this interface to receive the WebMessageReceived
/// event.
[uuid(ABABDC66-DF8D-487D-A737-7B25E8F835AA), object, pointer_default(unique)]
interface ICoreWebView2WebMessageReceivedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2WebMessageReceivedEventArgs* args);
}

/// Event args for the DevToolsProtocolEventReceived event.
[uuid(7EF09904-8B46-4FE1-87FF-5A28EFAF7723), object, pointer_default(unique)]
interface ICoreWebView2DevToolsProtocolEventReceivedEventArgs : IUnknown {
  /// The parameter object of the corresponding DevToolsProtocol event
  /// represented as a JSON string.
  HRESULT get_ParameterObjectAsJson([out, retval] LPWSTR*
                                    parameterObjectAsJson);
}

/// The caller implements this interface to receive
/// DevToolsProtocolEventReceived events from the WebView.
[uuid(8B0DF849-2D94-47FB-8072-FE7A4D5FBA6A), object, pointer_default(unique)]
interface ICoreWebView2DevToolsProtocolEventReceivedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2DevToolsProtocolEventReceivedEventArgs* args);
}

/// The caller implements this interface to receive CallDevToolsProtocolMethod
/// completion results.
[uuid(B7627F5F-8723-4ED3-AC20-F93104CDEA51), object, pointer_default(unique)]
interface ICoreWebView2CallDevToolsProtocolMethodCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status and result
  /// of the corresponding asynchronous method call.
  HRESULT Invoke([in] HRESULT errorCode, [in] LPCWSTR returnObjectAsJson);
}

/// The caller implements this interface to receive the CoreWebView2Host created
/// via CreateCoreWebView2Host.
[uuid(E09F5D38-91E3-49D1-8182-70A616AA06B9), object, pointer_default(unique)]
interface ICoreWebView2CreateCoreWebView2HostCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status and result
  /// of the corresponding asynchronous method call.
  HRESULT Invoke(HRESULT result, ICoreWebView2Host* created_host);
}

/// Event args for the NewWindowRequested event. The event is fired when content
/// inside webview requested to a open a new window (through window.open() etc.)
[uuid(DDBF77B3-3411-44AB-AA15-FDFC93AFFCF8), object, pointer_default(unique)]
interface ICoreWebView2NewWindowRequestedEventArgs : IUnknown
{
  /// The target uri of the NewWindowRequest.
  HRESULT get_Uri([out, retval] LPWSTR* uri);

  /// Sets a WebView as a result of the NewWindowRequest. The target
  /// webview should not be navigated. If the NewWindow is set, its top level
  /// window will return as the opened WindowProxy.
  HRESULT put_NewWindow([in] ICoreWebView2* newWindow);
  /// Gets the new window.
  HRESULT get_NewWindow([out, retval] ICoreWebView2** newWindow);

  /// Sets whether the NewWindowRequestedEvent is handled by host. If this is false
  /// and no NewWindow is set, the WebView will open a popup
  /// window and it will be returned as opened WindowProxy.
  /// If set to true and no NewWindow is set for a window.open call, the opened
  /// WindowProxy will be for an dummy window object and no window will load.
  /// Default is false.
  HRESULT put_Handled([in] BOOL handled);
  /// Gets whether the NewWindowRequestedEvent is handled by host.
  HRESULT get_Handled([out, retval] BOOL* handled);

  /// IsUserInitiated is true when the new window request was initiated through a user gesture
  /// such as clicking an anchor tag with target.
  HRESULT get_IsUserInitiated([out, retval] BOOL* isUserInitiated);

  /// Obtain an ICoreWebView2Deferral object and put the event into a deferred state.
  /// You can use the ICoreWebView2Deferral object to complete the window open
  /// request at a later time.
  /// While this event is deferred the opener window will be returned a WindowProxy
  /// to an unnavigated window, which will navigate when the deferral is complete.
  HRESULT GetDeferral([out, retval] ICoreWebView2Deferral** deferral);
}

/// The caller implements this interface to receive NewWindowRequested
/// events.
[uuid(715E10DD-2323-4F03-B6B3-AB34006B96D5), object, pointer_default(unique)]
interface ICoreWebView2NewWindowRequestedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2* sender,
      [in] ICoreWebView2NewWindowRequestedEventArgs* args);
}

/// The caller implements this interface to receive DocumentTitleChanged
/// events. Use the DocumentTitle property to get the modified
/// title.
[uuid(CF313728-68BC-4577-9A35-08E660544AD9), object, pointer_default(unique)]
interface ICoreWebView2DocumentTitleChangedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event. There are no event args and the args
  /// parameter will be null.
  HRESULT Invoke([in] ICoreWebView2* sender, [in] IUnknown* args);
}

/// Event args for the AcceleratorKeyPressed event.
[uuid(AF1587DD-E2FF-4BFF-8C1A-699D6D34C683), object, pointer_default(unique)]
interface ICoreWebView2AcceleratorKeyPressedEventArgs : IUnknown {
  /// The key event type that caused the event to be fired.
  HRESULT get_KeyEventKind([out, retval] CORE_WEBVIEW2_KEY_EVENT_KIND* keyEventKind);
  /// The Win32 virtual key code of the key that was pressed or released.
  /// This will be one of the Win32 virtual key constants such as VK_RETURN or
  /// an (uppercase) ASCII value such as 'A'. You can check whether Ctrl or Alt
  /// are pressed by calling GetKeyState(VK_CONTROL) or GetKeyState(VK_MENU).
  HRESULT get_VirtualKey([out, retval] UINT* virtualKey);
  /// The LPARAM value that accompanied the window message. See the
  /// documentation for the WM_KEYDOWN and WM_KEYUP messages.
  HRESULT get_KeyEventLParam([out, retval] INT* lParam);
  /// A structure representing the information passed in the LPARAM of the
  /// window message.
  HRESULT get_PhysicalKeyStatus(
      [out, retval] CORE_WEBVIEW2_PHYSICAL_KEY_STATUS* physicalKeyStatus);
  /// During AcceleratorKeyPressedEvent handler invocation the WebView is blocked
  /// waiting for the decision of if the accelerator will be handled by the host
  /// or not. If the Handled property is set to TRUE then this will
  /// prevent the WebView from performing the default action for this
  /// accelerator key. Otherwise the WebView will perform the default action for
  /// the accelerator key.
  HRESULT get_Handled([out, retval] BOOL* handled);
  /// Sets the Handled property.
  HRESULT put_Handled([in] BOOL handled);
}

/// The caller implements this interface to receive the AcceleratorKeyPressed
/// event.
[uuid(253D0AA2-6F85-4FB2-9D6B-0DC5FEDBB085), object, pointer_default(unique)]
interface ICoreWebView2AcceleratorKeyPressedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke(
      [in] ICoreWebView2Host* sender,
      [in] ICoreWebView2AcceleratorKeyPressedEventArgs* args);
}

/// Event args for the NewBrowserVersionAvailable event.
[uuid(5A86C3E7-511B-4F99-BC20-8A8ED5449C12), object, pointer_default(unique)]
interface ICoreWebView2NewBrowserVersionAvailableEventArgs : IUnknown {
  /// The browser version info of the current ICoreWebView2Environment
  HRESULT get_NewVersion([out, retval] LPWSTR* newVersion);
}

/// The caller implements this interface to receive NewBrowserVersionAvailable events.
/// Use the get_NewVersion method of ICoreWebView2NewBrowserVersionAvailableEventArgs
/// to get the new version number.
[uuid(865E16C4-A24D-4AC1-BC23-2E608CA313F9), object, pointer_default(unique)]
interface ICoreWebView2NewBrowserVersionAvailableEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event.
  HRESULT Invoke([in] ICoreWebView2Environment* webviewEnvironment,
                 [in] ICoreWebView2NewBrowserVersionAvailableEventArgs* args);
}

/// The caller implements this method to receive the
/// ContainsFullScreenElementChanged events. There are no event args for this
/// event.
[uuid(EC2AF7C6-4579-40AB-8C36-5CCEE58EB7CB), object, pointer_default(unique)]
interface ICoreWebView2ContainsFullScreenElementChangedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event. There are no event args and the args
  /// parameter will be null.
  HRESULT Invoke([in] ICoreWebView2* sender, [in] IUnknown* args);
}

/// The caller implements this interface to receive NewWindowRequested
/// events.
[uuid(1AE0297A-9671-4ED6-902A-4544B9B4AECD), object, pointer_default(unique)]
interface ICoreWebView2WindowCloseRequestedEventHandler : IUnknown {
  /// Called to provide the implementer with the event args for the
  /// corresponding event. There are no event args and the args
  /// parameter will be null.
  HRESULT Invoke([in] ICoreWebView2* sender, [in] IUnknown* args);
}

/// This represents the WebView2 Environment. WebViews created from an
/// environment run on the Browser process specified with environment parameters
/// and objects created from an environment should be used in the same environment.
/// Using it in different environments are not guaranteed to be compatible and may fail.
[uuid(7dc2ec84-56cb-4fcc-b4c6-a9f85c7b2894), object, pointer_default(unique)]
interface ICoreWebView2Environment : IUnknown {
  /// Asynchronously create a new WebView.
  ///
  /// parentWindow is the HWND in which the WebView should be displayed and
  /// from which receive input. The WebView will add a child window to the
  /// provided window during WebView creation. Z-order and other things impacted
  /// by sibling window order will be affected accordingly.
  ///
  /// It is recommended that the application set Application User Model ID for
  /// the process or the application window. If none is set, during WebView
  /// creation a generated Application User Model ID is set to root window of
  /// parentWindow.
  /// \snippet AppWindow.cpp CreateCoreWebView2Host
  ///
  /// It is recommended that the application handles restart manager messages
  /// so that it can be restarted gracefully in the case when the app is using
  /// Edge for webview from a certain installation and that installation is being
  /// uninstalled. For example, if a user installs Edge from Dev channel and
  /// opts to use Edge from that channel for testing the app, and then uninstalls
  /// Edge from that channel without closing the app, the app will be restarted
  /// to allow uninstallation of the dev channel to succeed.
  /// \snippet AppWindow.cpp RestartManager
  HRESULT CreateCoreWebView2Host(
    HWND parentWindow,
    ICoreWebView2CreateCoreWebView2HostCompletedHandler* handler);

  /// Create a new web resource response object. The headers is the
  /// raw response header string delimited by newline. It's also possible to
  /// create this object with empty headers string and then use the
  /// ICoreWebView2HttpResponseHeaders to construct the headers line by line.
  /// For information on other parameters see ICoreWebView2WebResourceResponse.
  ///
  /// \snippet SettingsComponent.cpp WebResourceRequested
  HRESULT CreateWebResourceResponse(
    [in] IStream* content,
    [in] int statusCode,
    [in] LPCWSTR reasonPhrase,
    [in] LPCWSTR headers,
    [out, retval] ICoreWebView2WebResourceResponse** response);

  /// The browser version info of the current ICoreWebView2Environment,
  /// including channel name if it is not the stable channel.
  /// This matches the format of the GetCoreWebView2BrowserVersionInfo API.
  /// Channel names are 'beta', 'dev', and 'canary'.
  ///
  /// \snippet AppWindow.cpp GetBrowserVersionInfo
  HRESULT get_BrowserVersionInfo([out, retval] LPWSTR* versionInfo);

  /// The NewBrowserVersionAvailable event fires when a newer version of the
  /// Edge browser is installed and available to use via WebView2.
  /// To use the newer version of the browser you must create a new
  /// environment and WebView.
  /// This event will only be fired for new version from the same Edge channel
  /// that the code is running from. When not running with installed Edge,
  /// no event will be fired.
  ///
  /// Because a user data folder can only be used by one browser process at
  /// a time, if you want to use the same user data folder in the WebViews
  /// using the new version of the browser,
  /// you must close the environment and WebViews that are using the older
  /// version of the browser first. Or simply prompt the user to restart the
  /// app.
  ///
  /// \snippet AppWindow.cpp NewBrowserVersionAvailable
  ///
  HRESULT add_NewBrowserVersionAvailable(
      [in] ICoreWebView2NewBrowserVersionAvailableEventHandler* eventHandler,
      [out] EventRegistrationToken* token);

  /// Remove an event handler previously added with add_NewBrowserVersionAvailable.
  HRESULT remove_NewBrowserVersionAvailable(
      [in] EventRegistrationToken token);
}

/// The caller implements this interface to receive the WebView2Environment created
/// via CreateCoreWebView2Environment.
[uuid(7ED79562-90E1-47CD-A4E0-01D9211D7E3D), object, pointer_default(unique)]
interface ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler : IUnknown {
  /// Called to provide the implementer with the completion status and result
  /// of the corresponding asynchronous method call.
  HRESULT Invoke(HRESULT result, ICoreWebView2Environment* created_environment);
}

/// A Receiver is created for a particular DevTools Protocol event and allows
/// you to subscribe and unsubsribe from that event.
/// Obtained from the WebView object via GetDevToolsProtocolEventReceiver.
[uuid(13FC668D-1F6D-4955-A4F4-D1EE7DEB5B74), object, pointer_default(unique)]
interface ICoreWebView2DevToolsProtocolEventReceiver : IUnknown {
  /// Subscribe to a DevToolsProtocol event.
  /// The handler's Invoke method will be called whenever the corresponding
  /// DevToolsProtocol event fires. Invoke will be called with the
  /// an event args object containing the DevTools Protocol event's parameter
  /// object as a JSON string.
  ///
  /// \snippet ScriptComponent.cpp DevToolsProtocolEventReceived
  HRESULT add_DevToolsProtocolEventReceived(
      [in] ICoreWebView2DevToolsProtocolEventReceivedEventHandler* handler,
      [out] EventRegistrationToken* token);
  /// Remove an event handler previously added with
  /// add_DevToolsProtocolEventReceived.
  HRESULT remove_DevToolsProtocolEventReceived(
      [in] EventRegistrationToken token);

}

/// DLL export to create a WebView2 environment with a custom version of Edge,
/// user data directory and/or additional browser switches.
///
/// browserExecutableFolder is the relative path to the folder that
/// contains the embedded Edge. The embedded Edge can be obtained by
/// copying the version named folder of an installed Edge, like
/// 73.0.52.0 sub folder of an installed 73.0.52.0 Edge. The folder
/// should have msedge.exe, msedge.dll, etc.
/// Use null or empty string for browserExecutableFolder to create
/// WebView using Edge installed on the machine, in which case the
/// API will try to find a compatible version of Edge installed on the
/// machine according to the channel preference trying to find first
/// per user install and then per machine install.
///
/// The default channel search order is stable, beta, dev, and canary.
/// When there is an override WEBVIEW2_RELEASE_CHANNEL_PREFERENCE environment
/// variable or applicable releaseChannelPreference registry value
/// with the value of 1, the channel search order is reversed.
///
/// userDataFolder can be
/// specified to change the default user data folder location for
/// WebView2. The path can be an absolute file path or a relative file path
/// that is interpreted as relative to the current process's executable.
/// Otherwise, for UWP apps, the default user data folder will be
/// the app data folder for the package; for non-UWP apps,
/// the default user data folder `{Executable File Name}.WebView2`
/// will be created in the same directory next to the app executable.
/// WebView2 creation can fail if the executable is running in a directory
/// that the process doesn't have permission to create a new folder in.
/// The app is responsible to clean up its user data folder
/// when it is done.
///
/// additionalBrowserArguments can be specified to change the behavior of the
/// WebView. These will be passed to the browser process as part of
/// the command line. See
/// [Run Chromium with Flags](https://aka.ms/RunChromiumWithFlags)
/// for more information about command line switches to browser
/// process. If the app is launched with a command line switch
/// `--edge-webview-switches=xxx` the value of that switch (xxx in
/// the above example) will also be appended to the browser
/// process command line. Certain switches like `--user-data-dir` are
/// internal and important to WebView. Those switches will be
/// ignored even if specified. If the same switches are specified
/// multiple times, the last one wins. Note that this also applies
/// to switches like `--enable-features`. There is no attempt to
/// merge the different values of the same switch. App process's
/// command line `--edge-webview-switches` value are processed after
/// the additionalBrowserArguments parameter is processed.
/// Also note that as a browser process might be shared among
/// WebViews, the switches are not guaranteed to be applied except
/// for the first WebView that starts the browser process.
/// If parsing failed for the specified switches, they will be
/// ignored. `nullptr` will run browser process with no flags.
///
/// environment_created_handler is the handler result to the async operation
/// which will contain the WebView2Environment that got created.
///
/// The browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// members of the environmentParams may be overridden by
/// values either specified in environment variables or in the registry.
///
/// When creating a WebView2Environment the following environment variables
/// are checked:
///
/// ```
/// WEBVIEW2_BROWSER_EXECUTABLE_FOLDER
/// WEBVIEW2_USER_DATA_FOLDER
/// WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS
/// WEBVIEW2_RELEASE_CHANNEL_PREFERENCE
/// ```
///
/// If an override environment variable is found then we use the
/// browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// values as replacements for the corresponding values in
/// CreateCoreWebView2EnvironmentWithDetails parameters.
///
/// While not strictly overrides, there exists additional environment variables
/// that can be set:
///
/// ```
/// WEBVIEW2_WAIT_FOR_SCRIPT_DEBUGGER
/// ```
///
/// When found with a non-empty value, this indicates that the WebView is being
/// launched under a script debugger. In this case, the WebView will issue a
/// `Page.waitForDebugger` CDP command that will cause script execution inside the
/// WebView to pause on launch, until a debugger issues a corresponding
/// `Runtime.runIfWaitingForDebugger` CDP command to resume execution.
/// Note: There is no registry key equivalent of this environment variable.
///
/// ```
/// WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER
/// ```
///
/// When found with a non-empty value, this indicates that the WebView is being
/// launched under a script debugger that also supports host applications that
/// use multiple WebViews. The value is used as the identifier for a named pipe
/// that will be opened and written to when a new WebView is created by the host
/// application. The payload will match that of the remote-debugging-port JSON
/// target and can be used by the external debugger to attach to a specific
/// WebView instance.
/// The format of the pipe created by the debugger should be:
/// `\\.\pipe\WebView2\Debugger\{app_name}\{pipe_name}`
/// where:
///
/// - `{app_name}` is the host application exe filename, e.g. WebView2Example.exe
/// - `{pipe_name}` is the value set for WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER.
///
/// To enable debugging of the targets identified by the JSON you will also need
/// to set the WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS environment variable to
/// send `--remote-debugging-port={port_num}`
/// where:
///
/// - `{port_num}` is the port on which the CDP server will bind.
///
/// Be aware that setting both the WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER and
/// WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS environment variables will cause the
/// WebViews hosted in your application and their contents to be exposed to
/// 3rd party applications such as debuggers.
///
/// Note: There is no registry key equivalent of this environment variable.
///
/// If none of those environment variables exist, then the registry is examined next.
/// The following registry keys are checked:
///
/// ```
/// [{Root}\Software\Policies\Microsoft\EmbeddedBrowserWebView\LoaderOverride\{AppId}]
/// "releaseChannelPreference"=dword:00000000
/// "browserExecutableFolder"=""
/// "userDataFolder"=""
/// "additionalBrowserArguments"=""
/// ```
///
/// In the unlikely scenario where some instances of WebView are open during
/// a browser update we could end up blocking the deletion of old Edge browsers.
/// To avoid running out of disk space a new WebView creation will fail
/// with the next error if it detects that there are many old versions present.
///
/// ```
/// ERROR_DISK_FULL
/// ```
///
/// The default maximum number of Edge versions allowed is 20.
///
/// The maximum number of old Edge versions allowed can be overwritten with the value
/// of the following environment variable.
///
/// ```
/// WEBVIEW2_MAX_INSTANCES
/// ```
///
/// If the Webview depends on an installed Edge and it is uninstalled
/// any subsequent creation will fail with the next error
///
/// ```
/// ERROR_PRODUCT_UNINSTALLED
/// ```
///
/// First we check with Root as HKLM and then HKCU.
/// AppId is first set to the Application User Model ID of the caller's process,
/// then if there's no corresponding registry key the AppId is
/// set to the executable name of the caller's process, or if that
/// isn't a registry key then '*'. If an override registry key is found then we
/// use the browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// registry values as replacements for the corresponding values in
/// CreateCoreWebView2EnvironmentWithDetails parameters. If any of those registry values
/// isn't present, then the parameter passed to CreateCoreWebView2Environment is used.
cpp_quote("STDAPI CreateCoreWebView2EnvironmentWithDetails(
    PCWSTR browserExecutableFolder,
    PCWSTR userDataFolder,
    PCWSTR additionalBrowserArguments,
    ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler* environment_created_handler);")

/// Creates an evergreen WebView2 Environment using the installed Edge version.
/// This is equivalent to calling CreateCoreWebView2EnvironmentWithDetails with
/// nullptr for browserExecutableFolder, userDataFolder, additionalBrowserArguments.
///  See CreateCoreWebView2EnvironmentWithDetails for more details.
cpp_quote("STDAPI CreateCoreWebView2Environment(
    ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler* environment_created_handler);")

/// Get the browser version info including channel name if it is not the stable channel
/// or the Embedded Edge.
/// Channel names are beta, dev, and canary.
/// If an override exists for the browserExecutableFolder or the channel preference,
/// the override will be used.
/// If there isn't an override, then the parameter passed to GetCoreWebView2BrowserVersionInfo is used.
cpp_quote("STDAPI GetCoreWebView2BrowserVersionInfo(
    PCWSTR browserExecutableFolder,
    LPWSTR* versionInfo);")

/// This method is for anyone want to compare version correctly to determine
/// which version is newer, older or same. It can be used to determine whether
/// to use webview2 or certain feature base on version.
/// Sets the value of result to -1, 0 or 1 if version1 is less than, equal or
/// greater than version2 respectively.
/// Returns E_INVALIDARG if it fails to parse any of the version strings or any
/// input parameter is null.
/// Input can directly use the versionInfo obtained from GetCoreWebView2BrowserVersionInfo,
/// channel info will be ignored.
cpp_quote("STDAPI CompareBrowserVersions(
    PCWSTR version1,
    PCWSTR version2,
    int* result);")
